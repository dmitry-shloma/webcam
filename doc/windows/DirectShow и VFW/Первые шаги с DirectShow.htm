<HTML>
<HEAD>
<TITLE>Первые шаги с DirectShow</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=windows-1251">
<LINK rel="stylesheet"  type="text/css"href="../article.css">
</HEAD>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-256273-3";
_uOsr[20]="yandex.ru"; _uOkw[20]="text";
_uOsr[21]="rambler.ru"; _uOkw[21]="words";
_uOsr[22]="poisk.ru"; _uOkw[22]="text";
_uOsr[23]="mail.ru"; _uOkw[23]="q";
_uOsr[24]="aport.ru"; _uOkw[24]="r";
urchinTracker();
</script>
<BODY>
<!--Rating@Mail.ru COUNTER--><img height=1 width=1
src="http://d4.ca.b1.a1.top.list.ru/counter?id=1156223"/><!--/COUNTER-->
<a href="http://directshow.wonderu.com/">> к содержанию</a>
<H1>Первые шаги с DirectShow<BR><SPAN class="subtitle"></SPAN></H1>
<H5><SPAN class="title">Автор: </SPAN><SPAN class="value"><A target="_blank" href="mailto:anonimshchik@mail.ru" title="">Анонимщик</A><BR></SPAN></H5>
<H6><SPAN class="title">Опубликовано: </SPAN><SPAN class="value">01.10.2006</SPAN><BR><SPAN class="title">Версия текста: </SPAN><SPAN class="value">1.0</SPAN></H6>
<DIV style="margin-left:2em"><A href="#IDA3IAKE"><B>Что такое DirectShow</B></A><BR><DIV style="margin-left:2em">
</DIV><A href="#IDAVJAKE"><B>Что такое фильтры</B></A><BR><DIV style="margin-left:2em">
</DIV><A href="#IDA4KAKE"><B>GraphEdit</B></A><BR><DIV style="margin-left:2em"><A href="#IDAJLAKE">Что это такое</A><BR><A href="#IDAULAKE">Кодеки</A><BR><A href="#IDAWMAKE">Потихоньку разбираемся</A><BR></DIV><A href="#IDACEAKE"><B>Отступление о синхронизации</B></A><BR><DIV style="margin-left:2em">
</DIV><A href="#IDALRAKE"><B>То же самое своими руками</B></A><BR><DIV style="margin-left:2em"><A href="#IDAORAKE">Вступление</A><BR><A href="#IDASRAKE">IGraphBuilder</A><BR><A href="#IDAYRAKE">Проигывание видеофайла и Intelligent connect</A><BR><A href="#IDAKVAKE">Конвертирование WAV&lt;-&gt;MP3</A><BR><A href="#IDAVZAKE">Захват и сохранение Real Audio/Video</A><BR><A href="#IDA1ZAKE">Конвертирование MOV&lt;-&gt;AVI</A><BR><A href="#IDA5ZAKE">Захват видео</A><BR><A href="#IDAD0AKE">Передача по сети</A><BR></DIV><A href="#IDAI0AKE"><B>DSPack</B></A><BR><DIV style="margin-left:2em"><A href="#IDAZ0AKE"></A><BR><A href="#IDA10AKE">TFilterGraph</A><BR><A href="#IDA2DBKE">TFilter</A><BR><A href="#IDAGHBKE">TVideoWindow</A><BR><A href="#IDA4UBKE">Свойства, методы и интерфейсы для TVideoWindow</A><BR><A href="#IDA13BKE">Класс TDSVideoWindowEx2</A><BR></DIV><A href="#IDAS5BKE"><B>Захват без отображения</B></A><BR><DIV style="margin-left:2em">
</DIV><A href="#IDAW5BKE"><B>Литература и ссылки</B></A><BR><DIV style="margin-left:2em">
</DIV>
</DIV>
<H2>Что такое DirectShow<A name="IDA3IAKE"></A></H2>
<P>Microsoft выпустила Video for Windows 1.x в ноябре 1992 года для Windows 3.1 в оптимизированном виде для захвата видео и сохранения его на диск. С тех пор показатели видеозахвата очень серьезно улучшились благодаря использованию шины PCI, bus mastering controllers, NT striped sets, Fast/Wide SCSI и прямой передачи захваченного видео из памяти адаптера на диск без промежуточного копирования данных в память. Несмотря на характеристики захвата, превышающие сейчас 20 мегабайт в секунду и большое количество клиентов для VfW, недостатки в архитектуре VfW с точки зрения необходимости поддержки видеоконференций потребовали разработки новой технологии видеозахвата.</P>
<P>Архитектуре VfW недостает важных свойтсв с точки зрения видеоконференций, телевизионного просмотра, захвата видеополей и поддержки дополнительных потоков данных таких, как VBI - vertical blanking interval - вертикальных интервалов гашения. Разнообразные производители расширили VfW путем реализации дополнительных возможностей. Однако, без стандартизации интерфейсов, приложения, использующие эти возможности, должны включать аппаратно-зависимый код. Тесная связь между драйверами захвата VfW и и драйверами дисплея значит то, что изменения, внесенные в драйвера захвата, требуют изменений и для драйверов дисплея.</P>
<P>Вдобавок, интерфейс VfW, AVICap не очень хорошо работает с DirectShow, поскольку AVICap распределяет буфера. Если к DirectShow доступаться через AVICap, буфера должны быть скопированы в точке передачи, что очень неэффективно. Для интеграции DVD, MPEG декодеров, видео-декодеров и тюнеров, расширений видеопортов (video port extensions - VPE) и аудио-кодеров на одном адаптере, необходима унифицированная драйверная модель, поддерживающая все эти устройства и управляющая их ресурсами.</P>
<P>DirectShow - это API, позволяющий Windows-приложениям управлять широким спектром устройств аудио/видео ввода, включающий (но не ограниченный) DV камеры, веб-камеры, DVD-устройства, карты TV-тюнеров. Оно поддерживает также различные форматы, от WAV и AVI до Windows Media. DirectShow, кроме этого, расширяемо, оно позволяет поддерживать устройства третьих производителей, форматы и компоненты обработки.</P>
<P>DirectShow предлагает как высокоуровневую модель приложения, позволяющую быстро разрабатывать цифровые медиаприложения, так и низкоуровневую классовую модель, позволяющую третьим производителям создавать собственные компоненты аудио и видео обработки.</P>
<P>Необходимо немного сказать об эволюции DirectShow. Она началась с поддержки в Windows 3.1 видеозахвата, предоставляемого моделью Видео для Windows (Video for Windows -VfW). VfW была прогрессивной технологией для своего времени, но имела серьезные ограничения. Одним из них было то, что менеджер видеокомпрессии (Video Compression Manager - VCM) не был разработан для управлениями кодеками, которые бы передавали видеофреймы в разном порядке во время сжатия. Таким образом, было затруднительно писать MPEG-кодеки, базирующиеся на VCM.</P>
<P>Windows также предоставлял простую поддержку аудио и видео проигрывания через набор команд MCI - Media Control Interface, который использовался драйверами mciavi. Хотя инфраструктура MCI допускала MPEG-декодеры, она никогда не была полностью портирована на 32-юитную архитектуру, и не базировалась на COM. Для снятия этих ограничений Microsoft начала проект, известный под названием Quartz, в котором была заложена поддержка проигрывания MPEG-1 для Windows.</P>
<P>В то время возникало множество новых устройств, таких, как цифровых видеокамер, новые медиформаты, такие, как MPEG-2 или DVD, и новые технологии, такие, как видеоконференции. Становилась понятной необходимость новой оболочки, позволяющей заставить работать вместе эти новые технологии максимально эффективно не только каждую саму по себе, но и под единым началом. Эта оболочка должна была быть расширяемое, чтобы третьи производители могли осуществлять поддержку своих специальных аппаратных средств, нестандартных форматов и процессов программной обработки. Эта оболочка должна была бы максимально упростить разработку программ, предоставить возможность низкоуровневого управления потоковыми операциями и модифицировать необходимые аудио и видео данные.</P>
<P>Для соответствия этим многочисленным требованиям группа разработчиков проекта Quartz начала с существующего проекта Clockwork. Clockwork был модульной оболочкой, в которой совместно работали полунезависимые компоненты, следуя предписаниям набора правил, для обработки медиапотоков. Группа разработчиков Quartz'а адаптировала эту модель для работы с Windows и обеспечила поддержку устройств третьих производителей. Результатом стала базирующуяся на COM потоковая архитектура, которая через шесть лет стала базисом сотен приложений под Windows.</P>
<P>Эта архитектура первоначально называлась ActiveMovie и впервые появилась в 1995 году с DirectX SDK. В 1996 году ActiveMovie была переименована в DirectShow. В 1998 году, вместе с DirectX Media 6.1, была добавлена поддержка для DVD и приложений аналогового телевидения. В 2000 году DirectShow стала частью DirectX SDK в составе DirectX 8.0, и допоолнительно стала поддерживать Windows Media Format, DirectShow Editing Services и API видеоредактирования.</P>
<H2>Что такое фильтры<A name="IDAVJAKE"></A></H2>
<P>Цифровые видеопотоки представляют собой последовательности видеофреймов, которые могут быть несжатыми RGB-изображениями или, если поток сжат, набором цировых значений, который можно декодировать для получения изображения. Обычно видео проигрывается со скоростью 25 или 30 кадров в секунду. Несжатый цифровой аудиопоток содержит последовательность значений, кождое  из которых есть целым, представляющую из себя квантованную (округленную) амплитуду аналогового сигнала в определенный момент времени. При качестве CD-аудио данные имеют точность 16 бит на отсчет и записываются и воспроизводятся как звук максимальной частоты 44,1 килогерц. Сжатый видеопоток не содержит действительных последовательностей данных, но, как и видеопоток, содержит значения, которые декодер использует для восстановления исходного потока перед тем, как подать его в звуковую карту.</P>
<P>Аудио и видеопотоки могут быть обработаны самыми разными способами. Они могут быть скомбинированы, проанализированы, перемешаны, скопированы, сгенерированы, изменены и т.д. В DirectShow все эти операции скрыты в фильтрах - COM-объектах, имеющих стандартное поведение. Фильтры, читающие файлы, расщепляющие бинарные данные на разные (например, аудио и видео) потоки - демультиплексоры, фильтры-компрессоры и фильтры-декомпрессоры, фильтры, отображающие аудио или видеоданные, фильтры - драйверы устройств - все это фильтры, которые знают, как они должны взаимодействовать, кроме обработки данных, - с другими фильтрами - для передачи потоковых данных. Приложения соединяют эти фильтры в необходимом порядке.</P>
<P>Фильтры могут быть трех основных типов: фильтры источников для ввода, фильтры преобразования для обработки и фильтры рендеринга для отображения информации.</P>
<P>Фильтр источника вводит данные в поток. Эти данные он может получать из файла или, например, видеокамеры, веб-камеры, TV-тюнера, сетевого потока и т.д. DirectShow тесно связана с моделью Windows-драйвером (Windows Driver Model - WDM); любое медиаустройство с правильно реализованным WDM-драйвером автоматически предоставляется для приложения как DirectShow фильтр источника. DirectShow предоставляет также фильтры источников для ввода данных из файлов, DVD- и VfW-устройств.</P>
<P>Фильтры преобразования получают входящие данные от некоторого другого фильтра, обрабатывают их и посылают следующему фильтру. Фильтры преобразования могут анализировать потоки, кодировать их и декодировать и т.д., т.е. проводить анализ или манипуляции над аудио и видеоданными. DirectShow предоставляет множество разнообразных фильтов преобразования для управления различными сжатиями и форматами файлов, включая аналоговые и телевизионные сигналы.</P>
<P>Фильтры рендеринга принимают данные от фильтров источников или преобразования и отображают их на экране, выводят через колонки, в файлы, устройства и т.д. Часть "Direct" в названии "DirectShow" отражает тот факт, что фильтры рендеринга используют технологии DirectDraw и DirectSound для передачи данных в видео- и звуковую карту. Вдобавок DirectShow поддерживает свойства потокого ядра, что позволяет таким устройствам захвата, как ТВ-тюнеры и DVD-устройства передавать данные на внешние устройства в режиме ядра для сохранения расходов переходов из режима ядра в пользовательский режим в случаях, когда приложение не требует этих данных.</P>
<P>Ниже приведена схема фильтров и их соединения при проигрывании avi-файла:</P>
<P><CENTER><IMG src="avi_filter_graph.GIF" title=""><BR><FONT face="verdana" style="font-size:x-small"><I></I></FONT>
</CENTER></P>
<P>Здесь фильтром источника есть File Source (Async), фильтами рендеринга - Video Renderer и Default DirectSound Device, а фильтами преобразования - AVI Splitter и AVI Decompressor.</P>
<H4>Для кого эта статья</H4>
<P>В первую очередь, для тех, кто задает на форумах вопросы вроде:</P>
<UL style="LIST-STYLE:square"><LI>Кто знает как передавать потоковое видео по локальной сети с тв-тюнера, по TCP/IP или по HTTP? </LI>
<LI>Хто знает где можно получить инфу о написание видео проигрывателя? </LI>
<LI>Моя программа выводит видео с захватывающего устройства. Пользователь нажимает кнопку и с живого видео выдергивается стопкадр. Проблема в том, что ... </LI>
</UL>
<P>За один месяц на медиа-форуме мастеров дельфи я насчитал вопросов, связанных с видео, касающихся DirectShow, около 15 (при общем их количестве ~120, т.е. 12,5%). При этом сознательно не касаюсь вопросов о звуке, поскольку сам звуковой тематикой вплотную не занимался. Впрочем, с точки зрения конечного программиста, эта статья покрывает достаточно много вопросов начинающих о работе со звуком. Т.е. эта статья может быть потенциально интересна четверти медиа-вопрошающих.</P>
<P>
</P>

<H2>GraphEdit<A name="IDA4KAKE"></A></H2>
<H3>Что это такое<A name="IDAJLAKE"></A></H3>
<P>Так называется майкрософтовская утилита, входящая в состав DirectShow SDK. С ее помощью можно соединять установленные и зарегистрированные в системе фильтры. Что она может нам дать? Во-первых, - без использования других программ и написания кода совершать различные манипуляции с медиа-файлами: конвертировать из одного формата в другой, извлекать из видеофайлов звуковые дорожки, захватывать "живое видео" и т.п. Во-вторых, это поможет нам быстрее понять, что такое DirectShow и ввести нас в круг его понятий - это будет полезно при чтении второй части статьи.</P>

<H3>Кодеки<A name="IDAULAKE"></A></H3>
<P>Они представляют фильтры, в более широком смысле - сборник фильтров (Codeck Pack). Перечислю наиболее известные:</P>
<UL style="LIST-STYLE:square"><LI>Codec Pack All in 1</LI>
<LI>K-Lite Codec Pack</LI>
<LI>Mega Codeck Pack</LI>
<LI>Nimo Codec Pack</LI>
</UL>
<P>и другие, поскольку вряд ли я в состоянии перечислить все необходимые. Смотрите также по ссылкам:</P>
<UL style="LIST-STYLE:square"><LI><A href="http://www.free-codecs.com/">http://www.free-codecs.com</A></LI>
<LI><A href="http://www.moviecodec.com/">http://www.moviecodec.com</A></LI>
<LI><A href="http://www.codeckpack.com/">http://www.codeckpack.com</A></LI>
</UL>
<P>и т.д. - далее по ссылкам на этих сайтах.</P>

<H3>Потихоньку разбираемся<A name="IDAWMAKE"></A></H3>
<P>Итак, запустим программу graphedt.exe - вот так должно выглядеть окно приложения:</P>
<P><CENTER><IMG src="GraphEdt1.GIF" title=""><BR><FONT face="verdana" style="font-size:x-small"><I>Рис. 1. Окно GraphEdit’а</I></FONT>
</CENTER></P>
<H4>Проигрывание видеофайла</H4>
<P>Жмем File-&gt;Render Media File ... - появляется окошео с приглашением выбрать media-файл. Я выбрал файл с именем new.avi (вы можете выбрать, конечно, что угодно другое, но рекомендую тоже avi-файл) и нажимаю OK. У меня получилось вот что:</P>
<P><CENTER><IMG src="GraphEdt2.GIF" title=""><BR><FONT face="verdana" style="font-size:x-small"><I>Рис. 2. Автоматически построенный граф фильтров</I></FONT>
</CENTER></P>
<P>Давайт в общих чертах разберемся, что здесь нарисовано. Картинка состоит из синеньких прямоугольничков, соединенных стрелочками. Первый прямоугольничек символизирует, видимо, наш исходный файл (напомню, он называется new.avi). Далее, по ходу стрелочки, видим следующий прямоугольник, в котором написано "AVI Splitter",- судя по названию, а также по двум исходящим из него стрелкам, он предназначен для того, чтобы взять данные от первого прямоугольничка и разделить их на два потока - нетрудно сообразить, что это - аудио- и видео- потоки. Входы и выходы в прямоугольнички в терминологии DirectShow представляют собой входящие и исходящие контакты (InputPin и OutputPin), а сами прямоугольнички - собственно фильтры (теперь мы сможем догадаться о причине ошибки, если увидим где-то сообщение о ней вроде "Действие не может быть выполнено, поскольку контакты не подключены" - речь идет именно об этих контактах). Вся же эта схема есть так называемым графом фильтров. Дальнейший анализ нашей картинки не должен представлять трудностей. Поэтому выберем пункты меню Graph-&gt;Play и посмотрим наше видео-аудио. Насмотревшись вдоволь, остановим просмотр (Graph-&gt;Stop или красненький квадратик на панеле инструментов) и немного поупражняемся в составлении графов фильтров вручную.</P>
<P>Для этого выберем File-&gt;New, откажемся от сохранения нашей работы в файл (впрочем, можете сохранять, авось пригодится).</P>
<P>Нашей следующей целью будет повторение того, что мы уже сделали, но вручную. Для этого выберем Graph-&gt;Insert Filters:</P>
<P><CENTER><IMG src="GraphEdt3.GIF" title=""><BR><FONT face="verdana" style="font-size:x-small"><I>Рис. 3. Окно выбора фильтра</I></FONT>
</CENTER></P>
<P>Нас пока будут интересовать DirectShow фильтры. Поэтому распахнем узел дерева "DirectShow Filters", найдем пункт "File Source (Async.)" и совершим на этом пукте двойной щелчок мышью (т.е. выберем этот фильтр). В появившемся окне диалога выбора медиа-файла укажем тот же, что и раньше, файл (new.avi). Появится прямоугольник с именем нашего файла. Если в той области, где находится надпись "Output" щелкнуть правой кнопкой мышки, увидим меню:</P>
<P><CENTER><IMG src="GraphEdt4.GIF" title=""><BR><FONT face="verdana" style="font-size:x-small"><I>Рис. 4. Автоматическое построение графа фильтров</I></FONT>
</CENTER></P>
<P>Заметим, что выбор пункта "Render Pin" приведет к построению графа, с которым мы уже знакомы: Рис. 2. Вы попробуйте это сделать, убедитесь, что я прав, а потом удалите ненужные элементы графа и вернитесь к этому месту. Дальше из той же категории "DirectShow Filters" выберем "Avi Splitter Filter" фильтр и соединим наши два имеющиеся в данный момент фильтра, протянув мышкой от исходящего контакта первого фильтра к входящему второго:</P>
<P><CENTER><IMG src="GraphEdt5.GIF" title=""><BR><FONT face="verdana" style="font-size:x-small"><I>Рис. 5. Построение графа фильтров вручную</I></FONT>
</CENTER></P>
<P>Остальное очевидно. Смотрим на <A href="">Рис.2</A>, выбираем соответствующие фильтры и соединяем их. Понятно, что GraphEdit, когда его просишь проиграть медиа-файл, каким-то образом узнает, какие нужны для этого фильтры и какие их контакты должны быть подключены. Разберемся с этим. Тем более, что это пригодится при написании собственных фильтов в том случае, если мы хотим сделать их доступными в процессе автоматического построения графа фильтров - утилита GraphEdit всего лишь вызывает API-функции для построения такого графа.</P>

<H4>IGraphBuilder</H4>
<P>Интерфейс - ДОПИСАТЬ</P>

<H4>Intelligent connect</H4>
<P>Каким образом GraphEdit узнает, какие нужны фильтры для проигрывания медиа-файла? Для этого используется специальный механизм - Intelligent Connect. Он описан в справке DirectShow, а я его сейчас перескажу в меру способностей.</P>
<P>Intelligent connect затрагивает следующие методы интерфейса IGraphBuilder (т.е. до этого места нужно уже дать представление о IGraphBuilder'е):</P>
<UL style="LIST-STYLE:square"><LI>Render</LI>
<LI>AddSourceFilter</LI>
<LI>RenderFile</LI>
<LI>Connect</LI>
</UL>
<P>Метод Render строит подсекцию графа. Он начинает обработку, начиная с первого несоединенного исходящего контакта и добавляет новые фильтры по мере необходимости. Стартовый фильтр (самый первый, то.есть - для нашего случая - File Source (Async)) уже должен быть в графе. На каждом новом шаге метод Render ищет фильтр, который можно соединить с текущим фильтром. </P>
<P>Для соединения каждого исходящего контакта метод Render проделывает следующие операции:</P>
<UL style="LIST-STYLE:square"><LI>Если контакт поддерживает интерфейс IStreamBuilder, менеджер графа фильтра делегирует весь процесс методу контакта IStreamBuilder::Render. Предоставляя этот интерфейс, контакт принимает на себя ответственность за построения остатка графа, вплоть до собственно рендеринга. Впрочем, немногие контакты поддерживают этот интерфейс.</LI>
<LI>Менеджер фильтра графа пытается использовать фильтры, закешированные в памяти, если такие есть. На протяжении всего процесса "интеллектуального соединения" менеджер графа фильтра пытается использовать кешированные фильтры из предыдущих шагов процесса.</LI>
<LI>Если граф фильтра содержит фильтры с несоединенными входными контактами, менеджер графа фильтра попытается соединить их  потом. Можно принудительно вызвать метод Render для попытки соединения с каким-то специфическим фильтром перед вызовом метода Render.</LI>
<LI>И последнее, менеджер графа фильтра ищет в реестре, используя метод IFilterMapper2::EnumMatchingFilters.Он пытается сопоставить исходящим контактам представленных медиа-типов мадиа-типы, находящиеся в реестре. </LI>
</UL>
<P>Каждый фильтр регистрируется с неким показателем (<I>merit</I>), числовой величиной, показывающей предпочтение фильтра в отношении других фильтров. Метод EnumMatchingFilters возвращает фильтры в порядке их этого показателя, с минимальным значением MERIT_DO_NOT_USE + 1. Игнорируются фильтры с показателем MERIT_DO_NOT_USE или меньшим. Фильтры также группируются в категории, определяемые посредством GUID. Эти категории имеют определенные показатели, и метод EnumMatchingFilters игнорирует любые из них с показателем MERIT_DO_NOT_USE или меньше, даже если фильтры в этой категории имеют и более высокие показатели.</P>
<P>Короче говоря, метод Render пытается соединить фильтры следующим образом:</P>
<UL style="LIST-STYLE:square"><LI>Используя IStreamBuilder.</LI>
<LI>Пытаясь использовать кешированные фильтры.</LI>
<LI>Пытаясь использовать фильтры в графе. (??? - что-то я зашился с переводом).</LI>
<LI>Просматривая фильтры в реестре.</LI>
</UL>
<P>ХОРОШО БЫ ЗДЕСЬ РАССМОТРЕТЬ ОДИН ИЛИ НЕСКОЛЬКО ПРИМЕРОВ</P>
<P>Продолжим, однако, рассмотрение методов, к которым имеет отношение Intelligent Connect.</P>
<P>Метод AddSourceFilter добавляет фильтр источника, который может произвести рендеринг указанного файла. Он просматривает реестр и сопоставляет расширению файла соответствующий протокол или набор предопределенных проверочных байтов (<I>check bytes</I>), которые задают определенный шаблон (ТОЖЕ ЧТО-ТО НЕ ТАК С ПЕРЕВОДОМ). Словом, этот метод находит подходящий фильтр источника, создает экземпляр этого фильтра, добавляет его в граф и вызывает метод IFileSourceFilte::Load с соответствующим именем файла.</P>
<P>ТОЖЕ БЫ ПРИМЕР</P>
<P>Метод RenderFile строит граф, отталкиваясь от имени файла. Внутри себя он использует AddSourceFilter для поиска корректного фильтра источника и Render для построения оставшейся части графа.</P>
<P>ПРИМЕР</P>
<P>Метод Connect соединяет исходящие и входящие контакты. Этот метод добавляет, если необходимо, промежуточные фильтры, используя вариации алгоритма, используемого для метода Render:</P>
<UL style="LIST-STYLE:square"><LI>Пытается напрямую соединить фильтры, без промежуточных фильтров.</LI>
<LI>Пытается использовать кешированные фильтры.</LI>
<LI>Пытается использовать фильтры в графе (???????)</LI>
<LI>Просматривает фильтры в реестре.</LI>
</UL>
<P>ПРИМЕР</P>

<H4>Конвертирование WAV &lt;-&gt; MP3</H4>
<P>Попытаемся теперь решить проблему, которая меня мучила несколько лет назад - никак не мог найти программу для конвертирования файлов формата mp3 в wav (а вот наоборот - без проблем). Мы сделаем то и другое, т.е. взаимообратное конвертирование.</P>
<P>Итак, запускаем GraphEdit, выбираем из DirectShow фильтров фильтр FileSource (Async.), в качестве входного файла указываем ему, например, "Вход в Windows.wav", дальше выбираем фильтры Wave Parser, LAME MPEG Layer III Audio Encoder (если каких-то из предыдущих или последующих фильтров вы у себя не найдете, ищите их в наборах кодеков по ссылкам, <A href="">приведенным выше</A>) и, наконец, фильтр Dump, который используется для записи,- он предложит задать имя файла, в который предполагается произвести конвертацию. Ну вот, все сделали, картинка будет иметь приблизительно такой вид:</P>
<P><CENTER><IMG src="GraphEdt6.GIF" title=""><BR><FONT face="verdana" style="font-size:x-small"><I>Рис. 6. WAV -&amp;gt; MP3</I></FONT>
</CENTER></P>
<P>Запустим граф: Graph-&gt;Play. Результатом его работы должен быть наш новый mp3-файл. Обратная процедура, конвертация  mp3  в wav, не должна теперь представлять для нас какой-то сложности. Рисунок графа фильтра ниже:</P>
<P><CENTER><IMG src="GraphEdt7.GIF" title=""><BR><FONT face="verdana" style="font-size:x-small"><I>Рис. 7. MP3-&amp;gt;WAV</I></FONT>
</CENTER></P>
<P>На самом деле я должен вас (или, скорее, себя) разочаровать - на поверку оказалось, что полученный wav-файл плохой, негодный. Видимо, какой-то из фильтров чего-то не того делает. Вполне возможно, что нужен еще какой-то фильтр для записи, например, заголовков. Короче, я не знаю.</P>
<P>Правда, я качал Nimo версии 5.91-бета и видел предупреждение, что могут быть проблемы. Ну ладно, в конце концов, если мне теперь припечет что-нибудь куда-нибудь конвертировать, я буду искать уже не готовые программы, а фильтры - это немного проще. Может быть, мне даже кто-то из читателей сообщит правильное решение.</P>

<H4>Конвертирование AVI&lt;-&gt;MP4</H4>
<P>Построим теперь графы фильтров для конвертирования файлов формата AVI в MPEG и наоборот.</P>
<P><CENTER><IMG src="GraphEdt11.GIF" title=""><BR><FONT face="verdana" style="font-size:x-small"><I>Рис. 8. AVI-&amp;gt;MP4</I></FONT>
</CENTER></P>
<P>И</P>
<P><CENTER><IMG src="GraphEdt12.GIF" title=""><BR><FONT face="verdana" style="font-size:x-small"><I>Рис. 9. MP4-&amp;gt;AVI</I></FONT>
</CENTER></P>
<P>Здесь не учтен звук - это будет домашним заданием.</P>

<H4>Захват и сохранение Real Audio/Video</H4>
<P>Перейдем теперь к еще одному когда-то интересовавшему меня вопросу: как сохранить в файл т.н. реал видео и аудио, а то как-то мне понравился какой-то клип, а я его смог смотреть только через интернет, поскольку ни браузер, ни медиа плеер (или что-то там такое) не давало возможности это видео-аудио сохранить.</P>
<P>Для этого нам понадобятся другие DirectShow-фильтры, ориентированные как раз на эту задачу. Сохранять мы будем, например, файл ...  (если к моменту вашего эксперимента ссылка будет уже недействительной, поищите в интернете подобные с расширениями *.rm, *.rv, *.ram и т.п. - всех не помню).</P>
<P>Вот написал я это, попытался было сделать, о чем расхвастался, сходу не вышло, и стал на протяжении нескольких дней разбираться что к чему. А что было делать - RenderFile не работает, GraphEdit глючит и вообще отказывается делать что бы то ни было - слетает при попытке соединить фильтры или просто отказывается для всех подозрительных фильтров, ориентированных на проигрывание файлов из сети, устанавливать для файла нелокальное имя. Пришлось даже в форумах спрашивать. Долгие поиски дали следующее.</P>
<P><A href="http://www.realnetworks.com/pro- ducts/producer/index.html">http://www.realnetworks.com/pro-%20ducts/producer/index.html</A></P>
<P>Для начала давайте поэкспериментируем с локальными файлами формата RealVideo. Первый вопрос - где их взять? Изначально их нет, из интернета так просто не скачаешь, поэтому, не особо мучась пока вопросом, как решить подобную проблему на все случаи жизни, я скачал программу Easy Real Converter, которую нашел по адресу <A href="http://www.share2.com/easy-real-converter/">http://www.share2.com/easy-real-converter/</A> , она небесплатная, но первые 10 конвертаций (я конвертировал из avi) выполняет даром (а больше мне и не нужно). Она, правда, почему-то отказалась конвертировать аудиопоток, ну да бог с ним - меньше проблем. Конвертировав свой avi-файл в файл формата Real Media, я получил материал, с которым смог работать. Для обратной конвертации, кстати, пригодится программка TINRA, которую можно взять здесь <A href="http://www.divx-digest.com/software/tinra.html">http://www.divx-digest.com/software/tinra.html</A> (у меня оно avi-файлы, правда, делало, но вот изображения там не видно было почему-то; ну да ладно, мы свой сделаем - не проблема - получилось, да только <A href="">время не то</A>).  РАЗОБРАТЬСЯ, что стоит RTSP://... - это какой-то ip? Как его узнать? Может, RTP фильтры справятся?</P>
<P>RFC </P>

<H4>Конвертирование MOV&lt;-&gt;AVI</H4>
<P>Еще одна, иногда возникающая, проблема. Давайте будем расти не только как программисты, но еще и решим конкретную задачу. Помнится, я как-то не смог даже при установленном QuickTime'е конвертировать с помощью какой-то (не помню какой) программы свой mov-файл в какой-нибудь другой формат. Разгадка оказалась и простой, и даже очевидной. У QuickTime'а свой формат, свой API, а для нас важно, что есть DirectShow фильтры, позволяющие работать с этим форматом унифицированным обрахом. Эти фильтры входят в состав QuickTime Alternative, который можно получить по адресу, например, ... . Если у вас их нет, советую установить (при установке, впрочем, нам будет предложено убрать настоящий QuickTime, если он установлен, иначе фильтр не устанавливается - почему так, я не понял; но я все же согласился с этим предложением и неудобств поа не чувствую; может быть, эту проблему и можно как-то обойти, но я не вникал) и продолжим.</P>
<P>Сначала попробуем просто проиграть mov-файл. Сразу оказывается, что для чтения файла с диска фильтр File Source (Async.) совершенно не подходит - у меня GraphEdit вообще вылетает при попытке открыть файл с его помощью. Что же, пусть это будет на совести разработчиков этой программы. Видимо, в данном случае попытка воспользоваться помощью Intelligent Connect терпит сокрушительную неудачу, а программисты не позаботились оформить соответствующие охраняемые блоки. В свое время мы будем умнее и учтем этот факт.</P>
<P>Проблема решается с помощью фильтра CyberLink QuickTime Source Filter (Direct SHow filters -&gt; CyberLink QuickTime Source Filter) - он должен присутствовать в системе, если QuickTime Alternative была установлена корректно. Выбираем его, указываем наш mov-файл, а затем в появившемся прямоугольничке делаем обоим контактам "Render Pin".  Результат должен выглядеть следующим образом:</P>
<P><CENTER><IMG src="GraphEdt9.GIF" title=""><BR><FONT face="verdana" style="font-size:x-small"><I>Рис 10. Воспроизведение MOV-файла</I></FONT>
</CENTER></P>
<P>Жмем Graph-&gt;Play и смотрим, все должно быть видно и слышно.</P>
<P>После этого уже нетрудно сообразить, как произвести конвертацию в формат avi-файла. Для этого, для начала, удалим фильтры "Video Render" и "Default DirectSound Device", затем добавим к графу фильтр AVI Mux и File Writer (посленему укажем имя - я назвал новый файл eee.avi) и можем спокойно запускать процесс:</P>
<P><CENTER><IMG src="GraphEdt10.GIF" title=""><BR><FONT face="verdana" style="font-size:x-small"><I>Рис. 11. MOV-&amp;gt;AVI</I></FONT>
</CENTER></P>
<P>Имейте в виду, я не отвечаю ни за размер файла, ни за синхронизацию видео и звука (ни в этом случае, ни в других). Пути решения возникающих проблем придется искать самостоятельно.</P>
<P>А вот обратную конвертацию, avi в mov, совершить не удалось. Кто знает, пусть поделится информацией.</P>

<H4>Захват видео</H4>
<P>Перейдем теперь к захвату видео с устройства захвата. Это может быть и плата захвата с одним видеовходом, и многоканальная карточка захвата, и веб-камера. По сравнению с предыдущими мучениями все пойдет на "ура" и с первого раза, тем более, что у меня в этом достаточный опыт и я уж раньше отмучился, а то не знаю, может быть, и здесь застопорился бы. Без лишних слов приведу картинку графа фильтров, а вашей задачей будет - модифицировать его под свою ситуацию:</P>
<P><CENTER><IMG src="GraphEdt8.GIF" title=""><BR><FONT face="verdana" style="font-size:x-small"><I>Рис. 12. Отображение «живого» видео</I></FONT>
</CENTER></P>
<P>Источник видео я выбрал из категории Video Capture Sources, видно, что у меня в системе установлено только одно устройство видеозахвата. Все, теперь можно жать кнопку Run и смотреть кино.</P>

<H4>Передача по сети</H4>
<P>Можно продолжать эксперименты, по-разному соединять фильтры, накладывать эффекты, конвертировать фалйлы и т.д. Рекомендую этим позаниматься какое-то время для набивания руки и осознания возможных подводных камней, а затем продолжить чтение о том, как делать то же самое, но уже полностью программным путем.</P>


<H2>Отступление о синхронизации<A name="IDACEAKE"></A></H2>
<P>В разделе о получении и сохранении <A href="">Real Audio и Video</A> мы столкнулись с ситуацией, когда конвертация из одного мультимедийного формата в другой приводило к рассинхронизации видео и аудио. Давайте уделим немного внимания этому и прочим, связанным с синхронизацией аудио и видео, моментов. В чем причина такого поведения, где ошибки и как можно было бы ее избежать. Такая рассинхронизация - не столь уж и редкое явление. Она возникает или может возникнуть как при захвате живого видео + аудио, так и при конвертировании из формата в формат. А потом появляются дискуссии, описанные, например, в <A href="http://forum.ixbt.com/0029/002398.html">http://forum.ixbt.com/0029/002398.html</A> (или см. <A href="..\..\..\..\..\Vovk\Projects\Article\Others\DeSynch.htm">здесь</A>). К концу прочтения этого раздела мы должны будем понимать, что правильно и что неправильно в этих обсуждениях.</P>
<P>Причина этого состоит в том, что где-то было неверно учтена привязка аудио и видео потоков к временным отсчетам. Предлагает ли DirectShow какие-то механизмы для решения такой проблемы?  Да, это так и есть, а в DirectShow MSDN есть раздел Time and Clocks in DirectShow (Время и часы в DirectShow). Рассмотрим эти моменты подробнее.</P>
<P>One function of the Filter Graph Manager is to synchronize all of the filters in the graph to the same clock, called the <I>reference clock</I>. </P>
<P>Любой объект, предоставяющий интерфейс IReferenceClock, может выполнять обязанности ссылочных часов. Ссылочные часы может предоставлять фильтр DirectShow - обычно это аудио рендерер, который имеет доступ к аппаратному таймеру. В качестве резервного варианта менеджер графа фильтров может использовать системное время. Базовый класс, содержащий этот интерфейс - CBaseReferenceClock.</P>
<P>Ссылочные часы могут измерять время с точностью до 100-наносекундного интервала. Для получения текущего времени ссылочных часов нужно вызвать метод IReferenceClock::GetTime. Хотя точность часов может варьировать, они всегда идут вперед (в худшем случае, когда, например, ссылочные часы привязываются к системному времени, а оно вдруг переводится назад, эти ссылочные часы будут стоять, пока новое время не превысит все старые отсчеты). </P>
<P>Менеджер графа фильтров автоматически выбирает ссылочные часы, когда граф запускается. Используется следующий алгоритм для выбора часов:</P>
<UL style="LIST-STYLE:square"><LI>Если приложение выбирает часы (см. ниже), то используются именно они.</LI>
<LI>Если граф содержит жильтр живого источника, поддерживающий IReferenceClock, используется этот фильтр (см. также далее о живом источнике).</LI>
<LI>Если граф не содержит фильтров живых источников, используется любой фильтр в графе, поддерживающий интерфейс IReferenceClock, его поиск начинается с рендерера проходом вверх по графу. Предпочтение при этом отдается фильтрам, включенным в граф (если граф рендерит аудио поток, этот шаг в алгоритме выделяет фильтр аудио рендерера).</LI>
<LI>Если фильтра, поддерживающего подходящие часы, не находится, используются специальные системно определенные часы (System Reference Clock), которые ориентируются на системное время.</LI>
</UL>
<P>Приложение может выбрать часы посредством вызова метода IMediaFilter::SetSyncSource менеджера графа фильтров. Это есть смысл делать, когда есть какие-то особые соображения, почему нужно отдать предпочтение этим часам.</P>
<P>Можно дать команду менеджеру графа фильтов не использовать ссылочные часы, вызвав SetSyncSource с параметром NULL. Это можно делать, например, для того, чтобы выполнять процесс так быстро, как можно. Для восстановления ссылочных часов, заданных по умолчанию, нужно вызвать метод менеджера графа фильтров IFlterGraph::SetDefaultSyncSource.</P>
<P>Всякий раз, когда изменяются ссылочные часы, менеджер графа фильтров уведомляет об этом каждый фильтр вызовом их метода IMediaFilter::SetSyncSource. Приложение не должно само вызывать этот метод фильтов.</P>
<P>Рассмотрим небольшой пример выбора часов и установки их в качестве ссылочных для графа. Будем вызывать этот метод, когда граф остановлен:</P>
<DIV id="IDARFAKE">
<TABLE class="code" width="98%"><TR><TD>
<PRE>
IGraphBuilder* pGraph = 0;
IReferenceClock* pClock = 0;
CoCreateInstance(CLSID_FilterGraph, NULL, CLSCTX_INPROC_SERVER, IID_IGraphBuilder, (<SPAN class="KEYWORD">void</SPAN> **) &amp;pGraph);
<SPAN class="COMMENT">// строим граф</SPAN>
pGraph-&gt;RenderFile(L<SPAN class="STRING">"C:\\Example.avi"</SPAN>, 0);
<SPAN class="COMMENT">// создаем часы</SPAN>
hr = CreateMyPrivateClock(&amp;pClock);
<SPAN class="KEYWORD">if</SPAN> (SUCCESSED(hr)){
<SPAN class="COMMENT">// устанавливаем часы для графа</SPAN>
IMediaFilter* pMediaFilter = 0;
pGraph-&gt;QueryInterface(IID_IMediaFilter, (<SPAN class="KEYWORD">void</SPAN> **) &amp;pMediaFilter);
pMediaFilter-&gt;SetSyncSource(pClock);
pClock-&gt;Release();
pMediaFilter-&gt;Release();
};
</PRE>
</TD></TR></TABLE>
</DIV>
<P>Предполагается, что функция CreateMyPrivateClock определена в приложении.</P>
<P>Можно использовать граф фильтров и вообще без часов, вызвав SetSyncSource(NULL). Тогда граф будет запущен так быстро, как возможно.</P>
<P>DirectShow определяет два соотносящихся времени: ссылочное и потоковое.</P>
<UL style="LIST-STYLE:square"><LI>Ссылочное время - это абсолютное время, возвращаемое ссылочными часами.</LI>
<LI>Потоковое время определяется в соответствии с последним запуском графа.</LI>
<LI>Когда граф стартовал впервые, потоковое время равно ссылочному времени минус время старта.</LI>
<LI>Когда граф приостановлен, потоковое время равным потоковому времени в тот момент, когда граф был приостановлен.</LI>
<LI>После операции поиска (seek) потоковое время сбрасывается в ноль.</LI>
<LI>Когда граф остановлен, потоковое время не определено.</LI>
</UL>
<P>Если медиа сэмпл имеет отметку о продолжительности времени, равное t, это значит, что этот сэмпл должен буть проигран за время t. В этом смысле потоковое время можно назвать также временем существования (presentation time).</P>
<P>Когда приложение вызывает метод IMediaControl::Run для запуска графа фильтров, менеджер графа фильтров вызывает метод IMediaFiler::Run для каждого фильтра. To compensate for the slight amount of time it takes for the filters to start running, the Filter Graph Manager specifies a start time slightly in the future.</P>
<P>Временная засечка (time stamp) определяет время начала и конца порции медиаданных, измеряемого потоковым временем. Она иногда называется временем существования (presentation time). Важно понимать, что не все форматы используют временные засечки именно таким образом. Например, не все MPEG - сэмплы их имеют. В графе фильтров для MPEG'а временные засечки не используются для каждого фрейма, пока они (фреймы) выходят из декодера (Ниче не понял:In MPEG filter graphs, the time stamp is not applied to each frame until they are output from the decoder).</P>
<P>Если фильтр рендеринга получает порцию данных, его работа основывается на временных отметках. Если сэмпл приходит позже (вероятно, имеется в виду следующая ситуация: сначала приходят данные о времени начала и конца сэмпла, а потом - сами данные, и эти данные идут долго очень) или не имеет временной отметки, фильтр рендерит этот сэмпл немедленно. В противном случае фильтр ждет времени начала сэмпла перед тем, как его прорендерить. (Это ожидание времени старта вызывается методом IReferenceClock::AdviseTime).</P>
<P>Фильтры источников и фильтры разборов отвечают за установку корректных временных меток на своих сэмплах. Используйте следующие указания.</P>
<UL style="LIST-STYLE:square"><LI>Проигрывание файла: Для первого сэмпла устанавливается стартовое время, равное нулю. Более поздние временные метки определяются длиной сэмпла и скоростью проигрывания, которые сами определяются форматом файла. Фильтр, разбирающий файл, отвечает за правильное вычисление меток (в качестве примера предлагается посмотреть AVI Splitter).</LI>
<LI>Видео и аудио захват: каждый сэмпл имеет временную метку со стартовым временем, равным потоковому времени, когда сэмпл был захвачен, со следующими предупреждениями:</LI>
<LI>Видео-фреймы с превью-контакта (в отличие от контакта захвата) не имеют временных меток. Из-за латентности графа видеофреймы, отмеченные временем захвата будут всегда приходить позже на видео рендерер (? - Because of graph latency, a video frame that is stamped with the capture time will always arrive late at the video renderer.). Это может быть в случае, еслии рендерер теряет фреймы, пытаясь соответствовать качеству. (Предлагается также посмотреть помощь на Quality-Control Management).</LI>
<LI>Аудио-захват: Фильтр аудиозахвата использует свой собственный набор буферов, отличающиеся от используемых аудиодрайвером. Аудиодрайвер заливает буфера фильтра захвата с фиксированными интервалами. Интервал зависит от драйвера, но обычно он не больше 10 миллисекунд. Временные отметки на аудиосэмплах отражают время, когда драйвер залил буфера фильтра аудиозахвата. Эти времена могут быть несколько неверными, особенно если приложение использует буфер очень маленького размера. Но, однако, времена медиа правильно отражают количество аудиосэмплов в буфере.</LI>
<LI>Фильтры смешивания (микширования - Mux): В зависимости от выходного формата, фильтру микширования может быть необходимо формировать временные метки или не делать этого. Например, формат файла AVI использует фиксированную скорость фреймов с временными метками, так что фильтр AVI Mux предполагает, что сэмплы приходят с приблизительно правильным временем. Если же входящие временные отметки свидетельствуют о дыре больше, чем в один фрейм, AVI Mux пишет индексный элемент с нулевым размером, что свидетельствует о пропущенном кадре (НЕ СОВСЕМ ПОНЯЛ, КАК ЭТО).  При проигрывании файла новые временные отметки генерируются в рантайме как описано ранее.</LI>
</UL>
<P>Для установки временной отметки сэмпла необходимо вызвать метод IMediaSample::SetTime.</P>
<P>Опционально фильтр также может установить медиа-время (media time) для сэмпла. В видеопотоке медиа-время представляет номер фрейма. В аудиопотоке медиа-время представляет номер сэмпла в пакете. Например, если каждый пакет содержит одну секунду аудио частотой 44.1kHz, первый пакет имеет начальное медиа-время, равное нулю, и конечное время, равное 44100. В потоке для поиска (seekable stream) медиа-время всегда относится к начальному времени потока. Например, предположим, что мы ищем 2 секунды от начала 15-fps видеопотока. Первый медиасэмпл после поиска будет иметь время засечки, равное нулю, но медиа-время, равное 30.</P>
<P>Фильтры рендеринга и микширования могут использовать медиа-время для определения, когда потеряны фреймы или сэмплы проверкой пропусков. Однако, фильтрам установка медиа-времени не необходима. Для установки медиа-времени сэмпла нужно вызывать метод IMediaSample::SetMediaTime.</P>
<P>Последняя теоретическая тема, которую необходимо рассмотреть в этом разделе, касается живых источников (live source) или, как их еще называют push source, получающие данные в реальном времени. Это может быть видеозахват или сетевое вещание. В общем, живые источники не могут управлять скоростью, с которой приходят данные.</P>
<P>Фильтр понимается как живой источник, если справедливы следующие утверждения :</P>
<UL style="LIST-STYLE:square"><LI>Фильтр возвращает флаг AM_FILTER_MISC_FLAGS_IS_SOURCE из метода IAMFilterMiskFlags::GetMiscFlags и, как минимум, один исходящий контакт поддерживает интерфейс IAMPushSource.</LI>
<LI>Фильтр поддерживает интерфейс IKsPropertySet и имеет контакт захвата (PIN_CATEGORY_CAPTURE). Предлагается посмотреть помощь по Pin Property Set.</LI>
</UL>
<P>Если фильтр живого источника имеет часы, менеджер графа фильтров отдаст предпочтение этим часам, когда будет выбирать ссылочные часы для графа.</P>
<P>Латентность фильтра (latency) это количество времени, которое берет фильтр для обработки сэмпла. Для живых источников латентность определяется размером буфера, используемого для хранения сэмпла. Предположим, например, что граф фильтра имеет источник видео с латентностью 33 миллисекунды и источник аудио с латентностью 500 миллисекунд. Каждый видеофрейм поступает на видео рендерер на, приблизительно, 470 миллисекунд раньше, чем ожидаемый соответствующий аудио сэмпл уйдет а аудио рендереру. Пока граф не скомпенсирует эту разницу, аудио и видео будут не синхронизированы.</P>
<P>Живой источник может быть синхронизирован посредством интерфейса IAMPushSource. Менеджер графа фильтров не синхронизирует живой источник, пока приложение не разрешит синхронизацию вызовом метода IAMGraphStreams::SyncUsingStreamOffset. Если синхронизация разрешена, менеджер графа фильтров запрашивает каждый фильтр источника на предмет IAMPushSource. Если фильтр поддерживает IAMPushSource, менеджер графа фильтров вызывает метод IAMLatency::GetLatency для получения ожидаемой латентности фильтра. (Интерфейс IAMPushSource наследует IAMLatency.) Комбинируя значения латентностей, менеджер графа фильтров определяет максимальную ожидаемую латентность в графе. И затем вызывает метод IAMPushSource::SetStreamOffset для получения для каждого фильтра источника смещения потока, </P>
<P>Этот метод предназначен, в первую очередь, для живого превью. Нужно, однако, заметить, что контакт превью устройства живого захвата (такого как камера) не выставляет временные метки на сэмплы. Т.о., для использования этого метода с устройством живого захвата нужно использовать превью с контакта захвата. Далее предлагается смотреть помощь по DirectShow Video Capture Filters.</P>
<P>В настоящее время интерфейс IAMPushSource поддерживается фильтром VFW Capture и фильтром Audio Capture.</P>
<P>ДАЛЬШЕ НЕ ПОНЯЛ НИХРЕНА ЧТО И К ЧЕМУ</P>
<P>Если фильтр рендеринга обрабатывает сэмплы, используя ссылочные часы, а фильтр источника продуцирует их, используя другие часы, при проигрывании файлов могут случаться затруднения. Рендерер может работать быстрее источника, порождая дыры в данных. Или медленнее источника, создавая заторы, так что иногда граф может терять сэмплы. Обычно живой источник не может управлять скоростью продуцирования, так что вместо рендеринга будет ожидаться скорость источника.</P>
<P>В настоящее время только аудио рендереры поддерживают ожидаемую скорость, потому что проблемы проигрывания аудио более заметны, чем проблемы с видео. Для поддержания ожидаемой скорости аудио рендерер должен предпринимать какие-то действия. Он использует следующий алгоритм:</P>
<UL style="LIST-STYLE:square"><LI>Если граф не использует ссылочные часы, аудиорендерер не пытается удержать скорость. (Когда граф не имеет ссылочных часов, сэмплы всегда рендерятся непосредственно сразу, как только поступают.)</LI>
<LI>С другой стороны, если граф имеет ссылочные часы, аудио рендерер проверяет все вышестоящие живые источники, используя критерии, описанные выше. Если нет, то аудио рендерер не ожидает скорости.</LI>
<LI>Если есть поток живого источника и этот источник предоставляет интерфейс IAMPushSource на свой исходящий контакт, то аудио рендерер вызывает метод IAMPushSource::GetPushSourceFlags. Это просматривает один из следующих флагов:</LI>
<LI>AM_PUSHSOURCECAPS_INTERNAL_RM. Этот флаг означает, что фильтр источника имеет свой собственный механизм поддержки скорости, так что аудиорендереру не нужно следить за скоростью.</LI>
<LI>AM_PUSHSOURCECAPS_NOT_LIVE. Этот флаг означает, что фильтр источника есть ненастоящим живым источником, даже несмотря на то, что он предоставляет интерфейс IAMPushSource. Т.о., аудиорендерер снова-таки не следит за скоростью.</LI>
<LI>AM_PUSHSOURCECAPS_PRIVATE_CLOCK. Этот флаг значит, что фильтр источника использует собственные часы для генерации временных меток. В этом случае аудиорендерер ожидает скорость в соответствии с временными метками. (Если, однако же, сэмплы не имеют временных меток, рендерер игнорирует этот флаг.)</LI>
<LI>Если GetPushSourceFlag не возвращает флагов (ноль), поведение аудиорендерера зависит от часов графа и того, имеют ли сэмплы временные метки:</LI>
<LI>Если аудиорендерер не используется графом для доступа к часам и сэмплы имеют временные метки, аудиорендерер ожидает скорости в соответствии с временными метками.</LI>
<LI>Если сэмплы не имеют временных меток, аудиорендерер ожидает скорости входящих аудиоданных.</LI>
<LI>Если аудиорендерер используется графом для доступа к часам, он ожидает скорости входящих данных.</LI>
</UL>
<P>Смысл последнего пункта в следующем: Если аудиорендерер имеет ссылочные часы, и фильтр источника использует те же часы для генерации временных меток, тогда аудиорендерер не ожидает скорости в соответствии с временными метками. If it did, in effect it would be trying to match rates with itself, which could cause the clock to drift. Therefore, in this case the renderer matches the rate of incoming audio data.</P>
<P>КОНЕЦ ПОЛНОГО НЕПОНИМАНИЯ</P>
<P>
</P>
<H2>То же самое своими руками<A name="IDALRAKE"></A></H2>
<H3>Вступление<A name="IDAORAKE"></A></H3>

<H3>IGraphBuilder<A name="IDASRAKE"></A></H3>
<P>Программно граф фильтра строится с помощью интерфеса IGraphBuilder. Для этого нужно получить интерфейс самомого IGraphBuilder'а, интерфейсы всех составлящих его фильтров и интерфейсы контактов каждого фильтра. После этого нужно соединить фильтры посредством их контактов, и можно запускать граф. Как это сделать, мы посмотрим в следующих пунктах, сейчас только замечу, что стандартные DirectShow фильтры, поставляемые в составе DirectShow, описаны в соответствующем разделе справки.</P>

<H3>Проигывание видеофайла и Intelligent connect<A name="IDAYRAKE"></A></H3>
<P>Сейчас мы построим программным путем граф фильтров, описанный в <A href="">Проигрывании видеофайла</A> .</P>
<P>Для простого проигрывания нет необходимости вручную строить весь граф фильтров. Графу фильтров нужно подсунуть фильтр источника, а все остальное сделает IntelligentConnect.</P>
<P>Давайте проведем две лабораторных работы. В первой добьемся проигрывания какого-нибудь avi-файла "как-нибудь", а во второй попытаемся добиться большего контроля.</P>
<P>1. Создаем новый проект, в секцию "uses" добавляем модули ActiveX и DirectShow, бросаем на форму TMainMenu, в котором создаем пункт "Open...", который отвечает за выбор видеофайла через диалог выбора файлов, и TOpenDialog. Поскольку мы будем работать с КОМ-объектами, то давайте сразу, при создании формы, добавим инициализацию: CoInitialize(nil), а при разрушении - CoUnitialize. Далее, для приложения нам понадобятся три интерфейса: IGraphBuilder, IMediaControl и IMediaEvent.</P>
<P>IGraphBuilder - это интерфейс графа фильтров. IMediaControl используется для управления запуском графом. IMediaEvent - для контроля и управлением поведения графа. </P>
<P>Я буду приводить упрощенный, схематический код, без проверок успешности выполнения тех или иных операций, но он обязательно должен быть полным в реальных приложениях. </P>
<DIV id="IDALSAKE">
<TABLE class="code" width="98%"><TR><TD>
<PRE>
<SPAN class="COMMENT">// Объявляем переменные:</SPAN>
<SPAN class="KEYWORD">var</SPAN> 
pGraphBuilder: IGraphBuilder = <SPAN class="KEYWORD">nil</SPAN>; 
pMediaControl: IMediaControl = <SPAN class="KEYWORD">nil</SPAN>; 
pMediaEvent : IMediaEvent = <SPAN class="KEYWORD">nil</SPAN>; 
<SPAN class="COMMENT">// Создаем граф фильтров:</SPAN>
CoCreateInstance(CLSID_FilterGraph, <SPAN class="KEYWORD">nil</SPAN>, CLSCTX_INPROC, IID_IGraphBuilder, pGraphBuilder);
<SPAN class="COMMENT">// Получаем интерфейсы IMediaControl и IMediaEvent:</SPAN>
pGraphBuilder.QueryInterface(IID_IMediaControl, pMediaControl);
pGraphBuilder.QueryInterface(IID_IMediaEvent, pMediaEvent);
<SPAN class="COMMENT">// Теперь дадаим команду графу, используя IntelligentConnect, построиться:</SPAN>
pGraphBuilder.RenderFile(StringToOleStr(OpenDialog1.FileName), <SPAN class="STRING">''</SPAN>);
<SPAN class="COMMENT">// Теперь даем команду на воспроизведение файла:</SPAN>
pMediaControl.Run;
<SPAN class="COMMENT">// И, наконец, ждем окончания воспроизведения:</SPAN>
pMediaEvent.WaitForCompletion(INFINITE, evCode);
</PRE>
</TD></TR></TABLE>
</DIV>
<P>Полный проект находится <A href="Samples\PlayVideo_Sample.zip">здесь</A>.</P>
<P>2. Теперь попробуем отобразить видео не где-попало, а в указанном нами месте. Предварительные шаги - добавление в "uses", инициализация и деинициализация - те же. Только добавим еще к форме панельку (TPanel), на которой и будем отображать видео.  Но нам понадобятся дополнительные интерфейсы: ICaptureGraphBuilder2 - используется для построения графа захвата, но нам он нужен будет для рендеринга файла так, как нам нужно; pSourceFile - фильтр файла-источника; и IVideoWindow - интерфейс окна для отображения в нем видео.</P>
<DIV id="IDANTAKE">
<TABLE class="code" width="98%"><TR><TD>
<PRE>
<SPAN class="COMMENT">// Объявляем переменные:</SPAN>
<SPAN class="KEYWORD">var</SPAN> 
pGraphBuilder : IGraphBuilder = <SPAN class="KEYWORD">nil</SPAN>; 
pCaptureGraphBuilder2: ICaptureGraphBuilder2 = <SPAN class="KEYWORD">nil</SPAN>; 
pSourceFile : IBaseFilter = <SPAN class="KEYWORD">nil</SPAN>; 
pMediaControl : IMediaControl = <SPAN class="KEYWORD">nil</SPAN>; 
pMediaEvent : IMediaEvent = <SPAN class="KEYWORD">nil</SPAN>; 
pVideoWindow : IVideoWindow = <SPAN class="KEYWORD">nil</SPAN>; 
<SPAN class="COMMENT">// Если в окне диалога выбора файлов что-то выбрано, то:</SPAN>
<SPAN class="COMMENT">// Создаем IGraphBuilder:</SPAN>
CoCreateInstance(CLSID_FilterGraph, <SPAN class="KEYWORD">nil</SPAN>, CLSCTX_INPROC, IID_IGraphBuilder, pGraphBuilder);
<SPAN class="COMMENT">// Создаем ICaptureGraphBuilder2:</SPAN>
CoCreateInstance(CLSID_CaptureGraphBuilder2, <SPAN class="KEYWORD">nil</SPAN>, CLSCTX_INPROC, IID_ICaptureGraphBuilder2, pCaptureGraphBuilder2);
<SPAN class="COMMENT">// Указываем нашему ядру рендеринга (лучше перевести "render engine" не могу) граф фильтров для использования:</SPAN>
pCaptureGraphBuilder2.SetFiltergraph(pGraphBuilder);
<SPAN class="COMMENT">// Теперь добавляем к графу фильтров фильтр источника следующим образом:</SPAN>
pGraphBuilder.AddSourceFilter(StringToOleStr(OpenDialog1.FileName), <SPAN class="STRING">''</SPAN>, pSourceFile);
<SPAN class="COMMENT">// Получаем интерфесы IMediaControl и IMediaEvent:</SPAN>
pGraphBuilder.QueryInterface(IID_IMediaControl, pMediaControl);
pGraphBuilder.QueryInterface(IID_IMediaEvent, pMediaEvent);
<SPAN class="COMMENT">// Рендерим нашей машиной раскраски (еще один вариант перевода):</SPAN>
pCaptureGraphBuilder2.RenderStream(<SPAN class="KEYWORD">nil</SPAN>, <SPAN class="KEYWORD">nil</SPAN>, pSourceFile <SPAN class="KEYWORD">as</SPAN> IBaseFilter, <SPAN class="KEYWORD">nil</SPAN>, <SPAN class="KEYWORD">nil</SPAN>);
<SPAN class="COMMENT">// Все готово для получения видеоокна:</SPAN>
hr := pGraphBuilder.QueryInterface(IID_IVideoWindow, pVideoWindow); 
<SPAN class="COMMENT">// Установим теперь владельца окна, стиль и положение:</SPAN>
pVideoWindow.put_Owner(Panel1.Handle); 
pVideoWindow.put_WindowStyle(WS_CHILD);
pVideoWindow.put_Left(0); 
pVideoWindow.put_Width(Panel1.Width); 
pVideoWindow.put_Top(0); 
pVideoWindow.put_Height(Panel1.Height); 
<SPAN class="COMMENT">// Осталось запустить:</SPAN>
pMediaControl.Run; 
pMediaEvent.WaitForCompletion(INFINITE, evCode); 
</PRE>
</TD></TR></TABLE>
</DIV>
<P>Все, с этой задачей мы справились. Полный код проекта можно взять <A href="Samples\PlayVideoOnOurWindow_Sample.ZIP">здесь</A>.</P>

<H3>Конвертирование WAV&lt;-&gt;MP3<A name="IDAKVAKE"></A></H3>
<P>Следующие наши эксперименты будем проводить без использования Intelligent Connect, поскольку одна из наших целей - понимание системы работы DirectShow, поэтому будем пытаться побольше работы выполнять руками. Поскольку, как мы помним, у меня были проблемы с конвертированием MP3 в WAV, будем заниматься только конвертацией WAV-MP3.</P>
<P>Что для этого будет нужно? Во-первых, граф фильтров - ни один проект без него не обойдется, во вторых интерфейс WaveParser'а - его CLSID узнать просто: запускаем GraphEdit, находим этот фильтр, и смотрим в дереве его DisplayName - оттуда и вычисляем, что CLSID равен D51BD5A1-7548-11CF-A520-0080C77EF58A; в-третьих - LAME MPEG Layer III Audio Encoder - тем же способом получаем, что его CLSID равен B8D27088-DF5F-4B7C-98DC-0E91A1696286; для фильтра Dump CLSID = 36A5F770-FE4C-11CE-A8ED-00AA002FEAB5. Собственно, это все, что нужно для успешного построения проекта.</P>
<DIV id="IDARVAKE">
<TABLE class="code" width="98%"><TR><TD>
<PRE>
<SPAN class="COMMENT">// Итак, объявляем константы и переменные:</SPAN>
<SPAN class="KEYWORD">const</SPAN> 
CLSID_WaveParser: TGUID = <SPAN class="STRING">'{D51BD5A1-7548-11CF-A520-0080C77EF58A}'</SPAN>;
CLSID_LameMPG3AE: TGUID = <SPAN class="STRING">'{B8D27088-DF5F-4B7C-98DC-0E91A1696286}'</SPAN>;
CLSID_Dump : TGUID = <SPAN class="STRING">'{36A5F770-FE4C-11CE-A8ED-00AA002FEAB5}'</SPAN>; 
<SPAN class="KEYWORD">var</SPAN> 
pGraphBuilder: IGraphBuilder = <SPAN class="KEYWORD">nil</SPAN>; 
pSourceFile : IBaseFilter = <SPAN class="KEYWORD">nil</SPAN>; 
pWaveParser : IBaseFilter = <SPAN class="KEYWORD">nil</SPAN>; 
pLameEncoder : IBaseFilter = <SPAN class="KEYWORD">nil</SPAN>; 
pDump : IBaseFilter = <SPAN class="KEYWORD">nil</SPAN>; 
pMediaControl: IMediaControl = <SPAN class="KEYWORD">nil</SPAN>; 
pMediaEvent : IMediaEvent = <SPAN class="KEYWORD">nil</SPAN>; 
</PRE>
</TD></TR></TABLE>
</DIV>
<P>Дальше, давайте подумаем о том, как мы будем получать входящие и исходящие контакты фильтров. Для интерфейса IBaseFilter существует метод EnumPins, который заполняет соответствующую структуру, и позволянт перебрать все контакты и узнать кое-какую информацию о них. Нам нужно будет получать для каждого фильтра входящие и исходящие контакты, поэтому неплохо бы написать функцию, которая по переданному интерфейсу и типу контакта (входящий или исходящий) будет выдавать контакт. Я вовсе не такой умный, чтобы писать такие функции, я просто посмотрел в MSDN, и нашел там приблизительно следующий варинт:</P>
<DIV id="IDAPWAKE">
<TABLE class="code" width="98%"><TR><TD>
<PRE>
<SPAN class="KEYWORD">function</SPAN> GetPin(pFilter: IBaseFilter; pinDir: PIN_DIRECTION): IPin; 
<SPAN class="KEYWORD">var</SPAN> 
bFound: Boolean; 
pEnum : IEnumPins; 
pPin : IPin; 
PinDirThis: PIN_DIRECTION; 
<SPAN class="KEYWORD">begin</SPAN> 
Result := <SPAN class="KEYWORD">nil</SPAN>; 
bFound := false; 
pFilter.EnumPins(pEnum); 
<SPAN class="KEYWORD">while</SPAN> (pEnum.Next(1, pPin, 0) = S_OK) <SPAN class="KEYWORD">do</SPAN> <SPAN class="KEYWORD">begin</SPAN> 
pPin.QueryDirection(PinDirThis); 
<SPAN class="KEYWORD">if</SPAN> (pinDir = PinDirThis) <SPAN class="KEYWORD">then</SPAN> <SPAN class="KEYWORD">begin</SPAN> 
bFound := true; 
break; 
<SPAN class="KEYWORD">end</SPAN>; 
<SPAN class="KEYWORD">end</SPAN>; 
pEnum.Reset; 
<SPAN class="KEYWORD">if</SPAN> bFound <SPAN class="KEYWORD">then</SPAN> Result := pPin; 
<SPAN class="KEYWORD">end</SPAN>; 
</PRE>
</TD></TR></TABLE>
</DIV>
<P>Я настолько свыкся с этим кодом, что уже даже не помню, вызывал он у меня какие-то вопросы или нет. Думаю, он более-менее ясен. Поэтому, если они у вас возникнут, рекомендую обращаться с DirectShow - справке. Нужно только заметить, что код будет правильео работать только в том случае, если у фильтров, попадающих на вход этой функции, будет не больше одного контакта соответствующего типа - иначе ничего не гарантировано. В нашем случае это именно так, поскольку мы используем конкретные фильтры, о которых все известно.</P>
<P>Что же, создаем КОМ-объекты и добавляем их к графу фильтров:</P>
<DIV id="IDATXAKE">
<TABLE class="code" width="98%"><TR><TD>
<PRE>
CoCreateInstance(CLSID_FilterGraph, <SPAN class="KEYWORD">nil</SPAN>, CLSCTX_INPROC, IID_IGraphBuilder, pGraphBuilder);
pGraphBuilder.AddSourceFilter(StringToOleStr(OpenDialog1.FileName), <SPAN class="STRING">''</SPAN>, pSourceFile);
CoCreateInstance(CLSID_WaveParser, <SPAN class="KEYWORD">nil</SPAN>, CLSCTX_INPROC, IID_IBaseFilter, pWaveParser);
pGraphBuilder.AddFilter(pWaveParser, <SPAN class="STRING">'Wave Parser'</SPAN>);
CoCreateInstance(CLSID_LameMPG3AE, <SPAN class="KEYWORD">nil</SPAN>, CLSCTX_INPROC, IID_IBaseFilter, pLameEncoder);
pGraphBuilder.AddFilter(pLameEncoder, <SPAN class="STRING">'Lame Mpeg Layer III Audio Encoder'</SPAN>);
CoCreateInstance(CLSID_Dump, <SPAN class="KEYWORD">nil</SPAN>, CLSCTX_INPROC, IID_IBaseFilter, pDump);
pGraphBuilder.AddFilter(pDump, <SPAN class="STRING">'Dump'</SPAN>);
</PRE>
</TD></TR></TABLE>
</DIV>
<P>Теперь нужно соединить фильтры между собой, а для этого нужно получить интерфейсы исходящего контакта для одного фильтра и входящего для другого, а затем соединить их с помощью соответствующего метода графа фильтров. Будем полагать, что у нас уже объявлены и проинициализированы (= nil) следующий переменные:</P>
<DIV id="IDAKYAKE">
<TABLE class="code" width="98%"><TR><TD>
<PRE>
pSourceOut : IPin; <SPAN class="COMMENT">// исходящий контакт фильтра источника</SPAN>
pWaveParserIn : IPin; <SPAN class="COMMENT">// входящий контакт фильтра 'Wave Parser'</SPAN>
pWaveParserOut : IPin; <SPAN class="COMMENT">// исходящий контакт фильтра 'Wave Parser'</SPAN>
pLameEncoderIn : IPin; <SPAN class="COMMENT">// входящий контакт фильтра 'Lame Encoder'</SPAN>
pLameEncoderOut: IPin; <SPAN class="COMMENT">// исходящий контакт фильтра 'Lame Encoder'</SPAN>
pDumpIn : IPin; <SPAN class="COMMENT">// входящий контакт фильтра 'Dump'</SPAN>
<SPAN class="COMMENT">// Получаем исходящий контакт фильтра источника:</SPAN>
pSourceOut := GetPin(pSourceFile, PINDIR_OUTPUT);
<SPAN class="COMMENT">// Получаем входящий контакт фильтра 'Wave Parser':</SPAN>
pWaveParserIn := GetPin(pWaveParser, PINDIR_INPUT);
<SPAN class="COMMENT">// Теперь соединяем фильтр источника и 'Wave Parser' посредством этих контактов:</SPAN>
pGraphBuilder.Connect(pSourceOut, pWaveParserIn);
<SPAN class="COMMENT">// Функция Connect как раз и производит соединение. Будем продолжать в том же духе:</SPAN>
pWaveParserOut := GetPin(pWaveParser, PINDIR_OUTPUT);
pLameEncoderIn := GetPin(pLameEncoder, PINDIR_INPUT);
pGraphBuilder.Connect(pWaveParserOut, pLameEncoderIn);
pLameEncoderOut := GetPin(pLameEncoder, PINDIR_OUTPUT);
pDumpIn := GetPin(pDump, PINDIR_INPUT);
pGraphBuilder.Connect(pLameEncoderOut, pDumpIn);
</PRE>
</TD></TR></TABLE>
</DIV>
<P>Все, мы полностью собрали вручную граф фильтров. Это, все-таки, довольно утомительная и однообразная работа, но ничего, зато мы теперь знаем, как это происходит. Остается установить имя mp3-файла, в который будет произведена конвертация. Для этого используем наш Dump, который, как и положено наследнику IFileSinkFilter, поддерживает метод установки имени файла:</P>
<DIV id="IDACZAKE">
<TABLE class="code" width="98%"><TR><TD>
<PRE>
(pDump <SPAN class="KEYWORD">as</SPAN> IFileSinkFilter).SetFileName(StringToOleStr(SaveDialog1.FileName), <SPAN class="KEYWORD">nil</SPAN>);
<SPAN class="COMMENT">// Осталось только получить интерфейсы IMediaControl и IMediaEvent и начать конвертацию:</SPAN>
pGraphBuilder.QueryInterface(IID_IMediaControl, pMediaControl);
pGraphBuilder.QueryInterface(IID_IMediaEvent, pMediaEvent);
<SPAN class="COMMENT">// Запускаем:</SPAN>
pMediaControl.Run;
pMediaEvent.WaitForCompletion(INFINITE, evCode);
</PRE>
</TD></TR></TABLE>
</DIV>
<P>Замечу, что, поскольку граф у нас именно конкретный, то не всякий файл можно подавать на вход. Но во всяком случай, файл 'Вход в Windows.wav' подходит. Вот и проверьте, насколько mp3 компактнее несжатого wav'а.</P>
<P>Готовый проект можно взять <A href="Samples\WavToMP3_Sample.zip">здесь</A>.</P>

<H3>Захват и сохранение Real Audio/Video<A name="IDAVZAKE"></A></H3>
<P>Следующий проект не должен представлять для нас абсолютно никаких сложностей - ведь почти все уже сделано.</P>

<H3>Конвертирование MOV&lt;-&gt;AVI<A name="IDA1ZAKE"></A></H3>

<H3>Захват видео<A name="IDA5ZAKE"></A></H3>

<H3>Передача по сети<A name="IDAD0AKE"></A></H3>

<H2>DSPack<A name="IDAI0AKE"></A></H2>
<P>Единственной известной мне дельфи-оберткой над DirectShow есть DSPack. Скачать ее можно со страницы <A href="http://www.progdigy.com/">http://www.progdigy.com</A>. (Сказать, что входит в ее состав кроме самого DSPack'а, а также дать ссылку и комментарии на JCL, откуда идет переложение для самого DirectShow.)</P>
<P>Об оберточных классах дает представление следующая иллюстрация, взятая из файла справки по DSPack:</P>
<P><CENTER><IMG src="DSPackClasses.GIF" title=""><BR><FONT face="verdana" style="font-size:x-small"><I>Рис. 13. Структура классов пакета DSPack</I></FONT>
</CENTER></P>
<P>Конечно, без хорошего знания DirectShow API трудно оценить качество и полезность классовой обертки. Но мы все же попробуем разобраться с этими классами.</P>
<H3><A name="IDAZ0AKE"></A></H3>

<H3>TFilterGraph<A name="IDA10AKE"></A></H3>
<P>Этот компонент - обертка над менеджером графа фильтров DirectShow и занимает исключительное место как в самом DirectShow, так и в DSPack'е. Любое приложение, имеющее дело с DirectShow, обязательно будет иметь дело и менеджером графа фильтров. Он используется для построения и управления графом, а также для управления синхронизацией, уведомлениями о событиях и других аспектах контроля графа.</P>
<P>При использовании API DirectShow для создания менеджера графа фильтров нужно пользоваться вызовом функции CoCreateInstance, а в качестве CLSID передавать либо CLSID_FilterGraph, либо CLSID_FilterGraphNoThread. CLSID_FilterGraph отвечает за создание менеджера графа фильтров (МГФ) на совместно используемом рабочем потоке (видимо, нужно все же дать представление об использовании потоков в DirectShow ), а CLSID_FilterGraphNoThread - за создание МГФ на потоке приложения.</P>
<P>Обычно приложения используют CLSID_FilterGraph. Но оба CLSID_ используются для создания того же объекта, но с использованием разных потоковых моделей:</P>
<UL style="LIST-STYLE:square"><LI>CLSID_FilterGraph служит для создания МГФ на рабочем потоке, который совместно используется всеми экземплярами CLSID_FilterGraph в одном процессе. Поток диспетчерезирует сообщения, которые посылают фильтры и управляет жизненным циклом любых окон, созданных фильтрами.</LI>
<LI>CLSID_FilterGraphNoThread служит для создания МГФ на потоке приложения. Если вы используете этот CLSID, то поток, вызывающий CoCreateInstance, должен иметь цикл обработки сообщений. В противном случае могут происходить разного рода блокировки (deadlock). Перед завершением работы этого потока нужно также освободить (release) МГФ и все объекты графа (такие, как фильтры, контакты, ссылочные часы и т.д.).</LI>
</UL>
<P>Исходя из вышеизложеного, вроде бы нет особых причин использовать при создании МГФ CLSID_FilterGraphNoThread. Впрочем, это можно и делать. ПРИМЕР.</P>
<P>Впрочем, компонент TFilterGraph не использует CLSID_FilterGraphNoThread, поэтому больше не будем о нем упоминать.</P>
<P>МГФ предоставляет следующие, кратко описанные, интерфейсы. Несмотря на то, что их достаточно много, я не поленюсь их все выписать, а вам советую не полениться и прочитать эту табличку. После этого вам станут намного понятнее права и обязаности менеджера графа фильтров.</P>
<TABLE border="0" cellspacing="2" cellpadding="5"><TR>
<TH><STRONG>№№</STRONG></TH>
<TH><STRONG>Интерфейс</STRONG></TH>
<TH><STRONG>Описание</STRONG></TH>
</TR>
<TR>
<TD>1</TD>
<TD>IAMGraphStreams</TD>
<TD>Управление графом фильтров (ГФ), работающим с живым источником</TD>
</TR>
<TR>
<TD>2</TD>
<TD>IAMStats</TD>
<TD>Позволяет приложению возвращать исполнимые данные от МГФ (???). Фильтры могут использовать этот интерфейс для записи исполнимых данных.Это, словом, для статистики - ничего не понял</TD>
</TR>
<TR>
<TD>3</TD>
<TD>IBasicAudio</TD>
<TD>Позволяет приложению управлять громкостью и балансом аудиопотока.</TD>
</TR>
<TR>
<TD>4</TD>
<TD>IBasicVideo</TD>
<TD>Позволяет приложению устанавливать видеосвойства, такие, как прямоугольники назначения и источника.</TD>
</TR>
<TR>
<TD>5</TD>
<TD>IBasicVideo2</TD>
<TD>Происходит от IBasicVideo и предоставляет дополнительный метод GetPrefferedAspectRatio.</TD>
</TR>
<TR>
<TD>6</TD>
<TD>IFilterChain</TD>
<TD>Предоставляет методы для старта, остановки или удаления цепочки фильтров в графе фильтров.</TD>
</TR>
<TR>
<TD>7</TD>
<TD>IFilterGraph</TD>
<TD>Предоставляет методы для построения графа фильтров. Приложения используют его для добавления фильтра в граф, соединения и рассоединения фильтров, удаления фильтров и других базисных операций. Однако, интерфейс IGraphBuilder происходит от этого интерфейса и предоставляет дополнительные методы, которые есть более <STRONG>sophistical</STRONG>. Таким образом, приложению удобнее пользоваться интерфейсом IGraphBuilder, а не IFilterGraph.</TD>
</TR>
<TR>
<TD>8</TD>
<TD>IFilterGraph2</TD>
<TD>Расширяет интерфейсы IFilterGraph и IGraphBuilder.</TD>
</TR>
<TR>
<TD>9</TD>
<TD>IFilterMapper2</TD>
<TD>Регистрирует и дерегистрирует фильтры, а также локализирует их в регистре. Реализует этот интерфейс вспомогательный объект Filter Mapper.</TD>
</TR>
<TR>
<TD>10</TD>
<TD>IGraphBuilder</TD>
<TD>Этот интерфейс предоставляет методы, пзволяющие приложению строить граф фильтров. Этот интерфейс реализует МГФ.Этот интерфейс наследуется от IFilterGraph (который предоставляет базовые операции - такие, как добавление фильтра в граф или соединение двух контактов) , и добавляет методы, позволяющие создавать граф по частичной информации.</TD>
</TR>
<TR>
<TD>11</TD>
<TD>IGraphConfig</TD>
<TD>Используется МГФ для поддержки динамического построения графа. Этот интерфейс позволяет приложениям и фильтрам переконфигурировать граф, находящийся в запущенном состоянии, без его остановки, и без потери данных.</TD>
</TR>
<TR>
<TD>12</TD>
<TD>IGraphVersion</TD>
<TD>Для получения версии МГФ.</TD>
</TR>
<TR>
<TD>13</TD>
<TD>IMediaControl</TD>
<TD>Предоставляет методы для управления потоком данных, проходящих через граф фильтров. Включает методы для запуска, приостановки и остановки графа. </TD>
</TR>
<TR>
<TD>14</TD>
<TD>IMediaEvent</TD>
<TD>Содержит методы для получения уведомлений о событиях и переопределения заданных по умолчанию обработчиков событий МГФ. </TD>
</TR>
<TR>
<TD>15</TD>
<TD>IMediaEventEx</TD>
<TD>Наследует и расширяет интерфейс IMediaEvent, позволяя окну приложения получать уведомления о происходящих событиях в МГФ.</TD>
</TR>
<TR>
<TD>16</TD>
<TD>IMediaEventSink</TD>
<TD>Уведомляет менеджер графа фильтров о событиях, происходящих на графе. Фильтры используют этот интерфейс для отчета о событиях. Приложения не используют его.</TD>
</TR>
<TR>
<TD>17</TD>
<TD>IMediaFilter</TD>
<TD>Управляет потоковым состоянием фильтра. Все фильтры DirectShow реализуют этот интерфейс. Он предоставляет методы переключения состояний (остановка, пауза, запуск), для получения текущего состояния и для установки ссылочных часов. Приложения не вызывают методов IMediaFilter. МГФ также предоставляет этот интерфейс. Приложения могут вызывать методы этого интерфейса SetSyncSource и GetSyncSource для установки и получения ссылочных часов. Приложения не должны вызывать других методов этого интерфейса, а вместо этого использовать методы IMediaControl.Сам IMediaFilter наследует от IPersist, а интерфейс IBaseFilter наследует, в свою очередь, от IMediaFilter.</TD>
</TR>
<TR>
<TD>18</TD>
<TD>IMediaPosition</TD>
<TD>Содержит методы для поиска позиции в потоке. Интерфейс IMediaSeeking основывается на этом интерфейсе. Приложения, написанные на C/C++, могут использовать интеерфейс IMediaSeeking вместо IMediaPosition. Но IMediaSeeking несовместим с автоматизацией, поэтому приложения, написанные, например, на Visual Basic'е, должны использовать IMediaPosition.Этот интерфейс предоставляется как МГФ, так и отдельными фильтрами. Приложения должны получать указатель на интерфейс IMediaPosition от МГФ, а не от фильтров. МГФ распределяет метод путем вызова всех фильтров рендеринга. Фльтры рендеринга распространяют вызов вверх по потоку к фильтрам источников. Такая последовательность событий гарантирует синхронизацию всех потоков.Если один из распеделенных вызовов вернет ошибку, МГФ вернет первую полученную им ошибку. Некоторые из распределенных вызовов могут быть и успешными. Если, впрочем, хоть один з распределеных вызовов вернет не E_NOTIMPL, то и МГФ не вернет E_NOTIMPL. Только в том случае, если все распределенные вызовы вернут E_NOTIMPL, МГФ вернет E_NOTIMPL.Замечание для разработчиков фильтров. Не нужно реализовывать этот интерфейс. Вместо этого нужно реализовывать IMediaSeeking. Если ваш фильтр поддерживает IMediaSeeking, МГФ автоматически будет управлять интерфейсом IMediaPosition.</TD>
</TR>
<TR>
<TD>19</TD>
<TD>IQueueCommand</TD>
<TD>Ставит команду в очередь для ее обработки в определенное время. Приложение может использовать его для продвижения вперед управляющих команд для графа(?).Методы этого интерфейса моделируют метод IDispatch::InvokeAt. Приложение указывает интерфейс, метод интерфейса, параметры метода и ссылочное время. МГФ ставит эту информацию в очередь и, затем, вызывает этот метод в указанное время. Требуемй интерфейс должен наследовать IDispatch и должен предоставляться МГФ. Примерами таких интерфейсов есть IMediaControl, IMediaEventEx и IMediaPosition.После постановки команды в очередь МГФ возвращает указатель на интерфейс IDefferedCommand. Приложение может использовать этот интерфейс для отмены или модифкации команды.</TD>
</TR>
<TR>
<TD>20</TD>
<TD>IRegisterServiceProvider</TD>
<TD>Регистрирует объект как сервис.</TD>
</TR>
<TR>
<TD>21</TD>
<TD>IResourceManager</TD>
<TD>Этот интерфейс отвечает за разрешение конкуренции за системные ресурсы.Фильтры могут использовать этот интерфейс для запроса ресурсов, которые, возможно, используют другие объекты. Например, аудио-рендереры (фильтры, воспроизводящие аудио) использую этот интерфейс для разрешения конфликтов за устройство аудио-вывода.Приложения, обычно, не используют этот интерфейс.</TD>
</TR>
<TR>
<TD>22</TD>
<TD>IServiceProvider</TD>
<TD>Этот интерфейс в справке по DirectShow не описан. Прочитать о нем можно в MSDN в разделе () следующее: </TD>
</TR>
<TR>
<TD>23</TD>
<TD>IVideoFrameStep</TD>
<TD>Этот интерфейс делает шаги через видеопоток. Этот интерфейс позволяет приложениям, использующим DirectShow, включая проигрыватели DVD, делать шаги по видеопотоку. МГФ управляет этим шаговым процессом в связке с фильтром оверлейного микширования или фильтром видеоотображения. Прокрутка назад не поддерживается.</TD>
</TR>
<TR>
<TD>24</TD>
<TD>IVideoWindow</TD>
<TD>Устанавливает свойства окна видеотображения. Приложения могут использовать этот интерфейс для установки владельца, позиции и размера окна и других его свойств.</TD>
</TR>
</TABLE>
<P>Как видите, интерфейсов достаточно много. По этой причине более подробно мы их рассматривать будем только в случае необходимости.</P>
<P>Нам нужны будут еще два интерфейса: IAMGraphBuilderCallback и IAMFilterGraphCallback. Первый из них предоставляет механизм callback'а при построении графа. Для его использования нужно реализовать его методы в приложении или клиентском объекте. Запрашивайте у МГФ интерфейс IObjectWithSize и вызывайте метод IObjectWithSize::SetSize, передавая указатель на реализацию этого интерфейса (ЧТО ЗА ИНТЕРФЕЙС ТАКОЙ? - НЕ НАШЕЛ ОПИСАНИЯ). МГФ вызывает методы этого интерфейса при построении графа, который (интерфейс) дает клиент в целях модификации процесса построения графа. Главное использование этого интерфейса - конфигурирование фильтра VMR перед  его соединением. Его можно использовать также для отказа использования неких фильтров (например, декодеров). Специфичекие методы этого интерфейса - SelectedFilter (вызывается, когда МГФ находит фильтр-кандидат, но перед созданием фильтра) и CreatedFilter (вызывается после того, как МГФ создает фильтр, но до попытки его соединить). Второй интерфейс - IAFilterGraphCallback, - тоже предоставляет callback-механизм при построении графа. Если при построении графа МГФ получает ошибку при попытке рендеринга некоторого контакта, он вызывает единственный метод этого интерфейса UnableToRender.</P>
<P>Так вот, класс TFilterGraph есть наследником TComponent, а также интерфейсов IAMGraphBuilderCallback, IAMFilterGraphCallback и IServiceProvider (об этом интерфейсе тоже нужно что-то сказать):</P>
<P>TFilterGraph = class(TComponent, IAMGraphBuilderCallback, IAMFilterGraphCallback, IServiceProvider)</P>
<P>МГФ может работать в трех режимах - gmNormal, gmCapture и gmDVD. При использовании режима gmNormal создается COM-объект IGraphBuilder (FFilterGraph), при использовании gmCapture - создаются COM-объекты ICaptureGraphBuilder2 (FCaptureGraph) и IGraphBuilder (FFilterGraph), при использовании gmDVD - COM-объект IDvdGraphBuilder (FDvdGraph). Давайте сначала рассмотрим эти интерфейсы, а затем продолжим исследование класса TFilterGraph.</P>
<P>Как уже было сказано (см. таблицу интерфейсов, предоставляемых МГФ), IGraphBuilder наследуется от IFilterGraph (который предоставляет базовые операции - такие, как добавление фильтра в граф или соединение двух контактов) , и добавляет методы, позволяющие создавать граф по частичной информации (единственный метод - Render - позволяет автоматически достроить граф для указанного исходящего контакта).</P>
<P>COM-объект "Построитель графа захвата" (Capture Graph Builder)  реализует единственный интерфейс - ICaptureGraphBuilder2 (для меня так и осталось невыясненным происхождение этого названия - возможно, он заменил и расширил используемый ранее для тех же целей интерфейс ICaptureGraphBuilder), который предоставляет методы для построения графа захвата и других пользовательских графов фильтров. В общем, использование этого вспомагательного объекта имеет свои особенности, но я не считаю, что на них нужно останавливаться (неплохо бы разобраться в том, как это helper-object работает и можно ли обойтись и без него).</P>
<P>Наконец, IDvdGraphBuilder используется для работы с, очевидно, dvd, но это тема отдельного разговора, и я постараюсь в дальнейшем о dvd не упоминать вообще.</P>
<P>Методы класса TFilterGraph позволяют обращаться к методам перечисленных в таблице интерфейсов. Причем эти методы в классе предоставляются очень избирательно, вроде SetVolume (для IBasicAudio), SetState, Play, Run и т.п. (для IMediaControl) или SetRate (для IMediaSeeking). Само собой, внутри этих методов идет обращение к соответствующим методам соответствующих интерфейсов. Поэтому возникает вопрос, стоило ли вообще выписывать эти методы в противовес невыписанным, которых подавляющее большинство. Как по мне, так не стоило. Ну да ладно. По крайней мере у нас есть повод рассматривать не DirectShow API, а дельфийскую библиотеку. TFilterGraph содержит также методы для добавления фильтров в граф и очистки его от фильтров. Но не предоставляет методов для их, фильтров, соединения (IGraphBuilder::Connect) и пр. и пр. Что, во-первых, странно (поскольку требовало от разработчиков минимальных усилий), а, во-вторых, настолько сбивает с толку начинающих (потому как даже не намекает им о том, что такое вообще возможно), что на многих форумах я неоднократно пересекался с людьми, которые достаточно долго (по несколько месяцев) имели дело с программами, работающими с видео (и писали их сами!), но не подозревали даже о фильтрах и о хоть каких бы то ни было принципах работы с ними. Что же, кроме справки по дельфи, нужно иногда читать и MSDN.</P>
<P>Подавляющее большинство прочих методов и свойств класса TFilterGraph имеют отношение к обработке сообщений, получаемых графом фильтров. Рассмотрим подробнее, как это происходит (хотя бы для того, чтобы уметь самим это делать в случае использования не DSPack, а непосредственно DirectShow API). Итак, в private-секции класса TFilterGraph можно найти интерфейс IMediaEventEx (член FMediaEventEx). При активизации менеджера графа фильтров (в реализации метода TFilterGraph.SetActive) происходит вызов метода QueryInterface для получения интерфейса IMediaEventEx. Сейчас самое место более подробно коснуться этого интерфейса, но начнем, пожалуй, с интерфейса IMediaEvent (IMediaEventEx наследует и расширяет его функциональность). Итак, интерфейс IMediaEvent содержит методы для возвращения уведомлений о событиях и для переопределения обработчиков этих уведомлений, предоставляемых по умолчанию МГФ. Как уже было сказано, этот интерфейс предоставляется МГФ. Приложение может использовать его для реакции на события, происходящие в графе фильтров, такие, как конец потока или ошибка при отображении (рендеринге). Фильтры посылают события в граф фильтров, используя интерфейс IMediaEventSink. Более подробно о событиях, возникающих в графе фильтров, стоит посмотреть в соответствующем разделе справки: ... . Интерфейс IMediaEvent предоставляет следующие методы:</P>
<TABLE border="0" cellspacing="2" cellpadding="5"><TR>
<TH><STRONG>Метод</STRONG></TH>
<TH><STRONG>Описание</STRONG></TH>
</TR>
<TR>
<TD>CancelDefaultHandling</TD>
<TD>Отменяет действие по умолчанию, выполняемое МГФ, для указанного сообщения</TD>
</TR>
<TR>
<TD>RestoreDefaultHandling</TD>
<TD>Восстанавливает поведение, заданное МГФ по умолчанию, для указанного события</TD>
</TR>
<TR>
<TD>FreeEventParams</TD>
<TD>Освобождает ресурсы, связанные с параметрами события. Этот метод следует вызывать после вызова метода GetEvent (см. ниже).</TD>
</TR>
<TR>
<TD>GetEvent</TD>
<TD>Возвращает уведомление о следующем событии из очереди сообщений.</TD>
</TR>
<TR>
<TD>GetEventHandle</TD>
<TD>Возвращает обработчик для события со сбросом вручную (manual-reset event) (если вы забыли или вообще не знаете, что это такое, почитайте в MSDN или посмотрите у Рихтера), который остается занятым (signaled), пока очередь содержит уведомления о событиях. УЯСНИТЬ СМЫСЛ, ПРОВЕРИТЬ ПЕРЕВОД.МГФ удерживает событие о сбросом вручную, которое отражает состояние очереди сообщений. Если очередь содержит уведомления о событиях, событие со сбросом вручную пребывает в занятом состоянии. Если очередь пуста, метод IMediaEvent::GetEvent сбрасывает событие.Приложение может использовать это событие для определения состояния очереди. Сначала вызывается метод GetEventHandle для получения хэндла события. Затем нужно дождаться, когда событие перейдет в сигнальное состояние, с помощью функции вроде WaitForSingleObject. Затем нужно получить седующее уведомление о событии из очереди с помощью вызова метода IMediaEvent::GetEvent. МГФ удерживает событие в сигнальном состоянии, пока очередь пуста; затем событие сбрасывается. Не следует закрывать хэндл события, возвращаемого этим методом, т.к. он используется внутри графа фильтров. Не нужно также использовать хэндл после после освобождения МГФ, поскольку в этом случае этот хэндл не будет корректным. (Чтобы избежать этой ошибки, можно дублировать хэндл вызовом DuplicateHandle и использовать этот дубликат вместо исходного хэндла. После окончания работы с дубликатом его нужно закрыть.)Другой способ мониторинга приложением очереди сообщений - вызов метода IMediaEventEx::SetNotifyWindow (он будет рассмотрен ниже).</TD>
</TR>
<TR>
<TD>WaitForCompletion</TD>
<TD>Ждет, когда граф фильтров обработает все доступные данные.</TD>
</TR>
</TABLE>
<P>Для мониторинга сообщений нас, впрочем, больше будет интересовать интерфейс IMediaEventEx, который наследует интерфейс IMediaEvent и, кроме того, имеет методы для для возвращения уведомлений о событиях и для переопределения обработчиков сообщений, предоставляемых МГФ по умолчанию. IMediaEventEx расширяет интерфейс IMediaEvent методами, позволяющими окну приложения получат сообщения о происходящих событиях в МГФ. Полный список определенных системой сообщений можно посмотреть здесь. Мы же обратимся к новым методам IMediaEventEx. Их всего три:</P>
<TABLE border="0" cellspacing="2" cellpadding="5"><TR>
<TH><STRONG>Метод</STRONG></TH>
<TH><STRONG>Описание</STRONG></TH>
</TR>
<TR>
<TD>SetNotifyWindow</TD>
<TD>Регистрирует окно, в которое будут посылаться уведомления о событиях. </TD>
</TR>
<TR>
<TD>SetNotifyFlags</TD>
<TD>Разрешает или запрещает уведомлять о событиях</TD>
</TR>
<TR>
<TD>GetNotifyFlags</TD>
<TD>Позволяет определить, разрешено ли уведомлять о событиях</TD>
</TR>
</TABLE>
<P>Как видим, смысл методов достаточно прозрачен, а чтобы еще сильнее понять их предназначение, смотрим в MSDN здесь.</P>
<P>Вернемся теперь к вопросу о реализации в классе TFilterGraph возможности обработки сообщений. Итак, в методе SetActive получаем интерфейс IMediaEventEx, разрешаем мониторинг событий (IMediaEventEx::SetNotifyFlags(0)) и устанавливаем окно, в которое МГФ будет посылать уведомления о происходящих событиях (IMediaEventEx::SetNotifyWindow(хэндл нашего окна, WM_GRAPHNOTIFY (некая заранее объявленная константа), ...)). Оконная процедура имеет следующий вид:</P>
<DIV id="IDAFCBKE">
<TABLE class="code" width="98%"><TR><TD>
<PRE>
<SPAN class="KEYWORD">procedure</SPAN> TFilterGraph.WndProc(<SPAN class="KEYWORD">var</SPAN> Msg: TMessage);
<SPAN class="KEYWORD">begin</SPAN>
  <SPAN class="KEYWORD">with</SPAN> Msg <SPAN class="KEYWORD">do</SPAN>
    <SPAN class="KEYWORD">if</SPAN> Msg = WM_GRAPHNOTIFY <SPAN class="KEYWORD">then</SPAN>
      <SPAN class="KEYWORD">try</SPAN>
        HandleEvents;
      <SPAN class="KEYWORD">except</SPAN>
...
<SPAN class="KEYWORD">end</SPAN>;
</PRE>
</TD></TR></TABLE>
</DIV>
<P>А вот реализация метода HandleEvents:</P>
<DIV id="IDA3CBKE">
<TABLE class="code" width="98%"><TR><TD>
<PRE>
<SPAN class="KEYWORD">procedure</SPAN> TFilterGraph.HandleEvents;
<SPAN class="KEYWORD">var</SPAN>
  hr: HRESULT;
  Event, Param1, Param2: Integer;
<SPAN class="KEYWORD">begin</SPAN>
  <SPAN class="KEYWORD">if</SPAN> assigned(FMediaEventEx) <SPAN class="KEYWORD">then</SPAN>
  <SPAN class="KEYWORD">begin</SPAN>
    hr := FMediaEventEx.GetEvent(Event, Param1, Param2);
    <SPAN class="KEYWORD">while</SPAN> (hr = S_OK) <SPAN class="KEYWORD">do</SPAN>
    <SPAN class="KEYWORD">begin</SPAN>
      DoEvent(Event, Param1, Param2);  <SPAN class="COMMENT">// внутри этого вызова и вызывается соответствующий обработчик</SPAN>
      FMediaEventEx.FreeEventParams(Event, Param1, Param2);
      hr := FMediaEventEx.GetEvent(Event, Param1, Param2);
    <SPAN class="KEYWORD">end</SPAN>;
  <SPAN class="KEYWORD">end</SPAN>;
<SPAN class="KEYWORD">end</SPAN>;
</PRE>
</TD></TR></TABLE>
</DIV>
<P>Рекомендую посмотреть в инспекторе объектов на обработчики событий, а я буду считать, что успешно закончил рассмотрение этого класса.</P>

<H3>TFilter<A name="IDA2DBKE"></A></H3>
<P>Следующий интересующий нас класс - TFilter. Не нужно быть особо догадливым, чтобы понять, что он есть оболочкой над интерфейсом, представляющим фильтр - IBaseFilter. Этот интерфейс предоставляет методы для управления фильтром. Его реализуют все фильтры DirectShow. МГФ использует этот интерфейс для управления фильтрами. Приложения же могут его использовать для перечисления контактов или для запроса информации о фильтре, но не для изменения состояния фильтра (каждый фильтр может находиться в одном из трех состояний: запущенном, остановленном или приостановленном (пауза)). Для этой цели нужно использовать интерфейс IMediaControl, предоставляемый МГФ. Поскольку этот интерфейс уже неоднократно упоминался, займемся им более плотно. Он предоставляет методы для управления потоком данных через граф фильтров. Вдобавок к методам, наследуемым от IDispatch, интерфейс IMediaControl предоставляет следующие:</P>
<TABLE border="0" cellspacing="2" cellpadding="5"><TR>
<TH><STRONG>Метод</STRONG></TH>
<TH><STRONG>Описание</STRONG></TH>
</TR>
<TR>
<TD>Run</TD>
<TD>Запускает все фильтры в графе фильтров</TD>
</TR>
<TR>
<TD>Pause</TD>
<TD>Приостанавливает все фильтры в графе фильтров</TD>
</TR>
<TR>
<TD>Stop</TD>
<TD>Останавливает все фильтры в графе фильтров</TD>
</TR>
<TR>
<TD>StopWhenReady</TD>
<TD>Приостанавливает граф фильтров, позволяет фильтрам поставить приходящие им данные в свои очереди, а затем останавливает граф фильтров</TD>
</TR>
<TR>
<TD>GetState</TD>
<TD>Возвращает текущее состояние графа фильтров</TD>
</TR>
</TABLE>
<P>В особые объянения этих методов я входить не буду, считая их интуитивно понятными, хотя на самом деле поговорить есть о чем - исследование деталей изменения состояний отдельных фильтров и всего графа фильтров - это отдельный и интересный разговор.</P>
<P>Сделав это отступление, вернемся к нашему интерфейсу IBaseFilter. Но, поскольку он наследует другой интерфейс - IMediaFilter, рассмотрим сначала методы последнего (ТУТ БЫ (ИЛИ ДАЛЬШЕ) - КАРТИНКУ С ИЛЛЮСТАЦИЕЙ НАСЛЕДОВАНИЯ ИНТЕРФЕЙСОВ). Именно он предоставляет методы для управления потоковым состоянием фильтра. Как уже было сказано, его предоставляют все фильтры DirectShow (поскольку они предоставляют интерфейс IBaseFilter, наследующий IMediaFilter; нужно, кстати, сказать, что сам IMediaFilter наследует от интерфейса IPersist). Итак, интерфейс IMediaFilter предоставляет методы для изменения состояния фильтра (остановка, запуск, пауза(приостановка)); для возвращения текущего состояния фильтра; для установки ссылочных часов. Приложения же, однако, не должны использовать интерфейса IMediaFilter, предоставляемых фильтрами. Вместо этого они могут использовать только тот же интерфейс - IMediaFilter, предоставляемый МГФ. Впрочем, они могут использовать только два метода этого интерфейса - SetSyncSource (для установки ссылочных часов для графа) и GetSyncSource (для получения этих часов). Остальные методы они вызывать не должны. Вместо этого рекомендуется использовать соответствующие методы интерфейса IMediaControl. Несмотря на это, для справки приведу таблицу методов IMediaFilter (кроме тех, что наследуются от IPersist):</P>
<TABLE border="0" cellspacing="2" cellpadding="5"><TR>
<TH><STRONG>Метод</STRONG></TH>
<TH><STRONG>Описание</STRONG></TH>
</TR>
<TR>
<TD>Stop</TD>
<TD>Останавливает фильтр</TD>
</TR>
<TR>
<TD>Pause</TD>
<TD>Приостанавливает фильтр</TD>
</TR>
<TR>
<TD>Run</TD>
<TD>Запускает фильтр</TD>
</TR>
<TR>
<TD>GetState</TD>
<TD>Возвращает состояие фильтра (запущен, остановлен, приостановлен)</TD>
</TR>
<TR>
<TD>SetSyncSource</TD>
<TD>Устанавливает ссылочные часы для фильтра или графа фильтров</TD>
</TR>
<TR>
<TD>GetSyncSource</TD>
<TD>Возвращает текущие ссылочные часы</TD>
</TR>
</TABLE>
<P>Теперь пришел черед вернуться к методам интерфейса IBaseFilter. Кроме методов IMediaFilter, он предоставляет еще и следующие:</P>
<TABLE border="0" cellspacing="2" cellpadding="5"><TR>
<TH><STRONG>Метод</STRONG></TH>
<TH><STRONG>Описание</STRONG></TH>
</TR>
<TR>
<TD>EnumPins</TD>
<TD>Перечисляет контакты фильтра</TD>
</TR>
<TR>
<TD>FindPin</TD>
<TD>Возвращает контакт с указанным идентификатором</TD>
</TR>
<TR>
<TD>JoinFilterGraph</TD>
<TD>Уведомляет фильтр, что он связан или <STRONG>left(?)</STRONG> графом фильтров.Когда МГФ добавляет фильтр в граф фильтров, он вызывает этот метод с указателем на себя. Имя экземпляра фильтра связывается посредством второго параметра. Когда МГФ удаляет фильтр из графа, он вызывает этот метод, передавая в качестве указателя на граф значение nil. Приложениям этот метод вызывать не следует. Для добавления фильтра в граф нужно вызвать метод AddFilter интерфейса IFilterGraph, полученного у МГФ</TD>
</TR>
<TR>
<TD>QueryFilterInfo</TD>
<TD>Возвращает информацию о фильтре</TD>
</TR>
<TR>
<TD>QueryVendorInfo</TD>
<TD>Возвращает строку, содержащую информацию о производителе</TD>
</TR>
</TABLE>
<P>Это, в общем, и все, что я хотел сказать об интерфейсе IBaseFilter и, соответственно, классе TFilter, поскольку последний реализует простейшие и очевиднейшие вещи, необходимые для того, чтобы называться враппером этого интерфейса. Если вас заинтересуют подробности упомянутых выше интерфейсов или их методов, смотрите их в MSDN.</P>
<P>
</P>

<H3>TVideoWindow<A name="IDAGHBKE"></A></H3>
<P>Мы же продолжим знакомство с классами-обертками над COM-объектами DirectShow. Следующим будет TVideoWindow - компонент, используемый для отображения (рендеринга - rendering) проходящих через граф фильтров данных. Он есть оберточным классом над, в первую очередь, интерфейсом IVideoWindow и, во вторую (в зависимости от режима отображения), над IVMRWindowlessControl9. О последнем интерфейсе поговорим чуть позже, а сейчас займемся IVideoWindow, - понимание работы с ним и задач, им выполняемых, чрезвычайно важно, в первую очередь, для понимания множества нюансов собственно видеовывода в DirectShow.</P>
<H4>IVideoWindow</H4>
<P>Итак, интерфейс IVideoWindow предназначен для работы со свойствами окна видеовывода. Приложения могут использовать его для установки владельца окна, его положения и размеров и других свойств. Его (этот интерфейс, IVideoWindow) предоставляют как фильтр видеорендеринга, так и МГФ. Приложения должны использовать версию МГФ этого интерфейса. МГФ перенаправляет вызовы всех методов видеорендереру. Пересылает он, также, и отдельные оконные сообщения, такие, как WM_DISPLAYCHANGE, которые нужны видеорендереру для самообновления. Если поместить окно видеовывода на дочернем окне, то оно уже не будет напрямую получать оконные сообщения. Но их будет пересылать МГФ.</P>
<P>Однако, если граф фильтров содержит более одного видеорендерера, МГФ взаимодействует только с одним из них (указанным отдельно). Таким образом, работая с несколькими видеоокнами, приложение должно использовать интерфейс IVideoWindow на соответствующем фильтре напрямую. В этом случае нужно пересылать оконные сообщения каждому видеорендереру, используя метод IVideoWindow::NotifyOwnerMessage.</P>
<P>Приложения, которые устанавливают видеоокна в дочерние окна, должны устанавливать пустым обработчик сообщения WM_ERASEBKGND, чтобы избежать неверного отображения содержания окна.</P>
<P>Если видеорендерер не соединен с другими фильтрами, все методы на этом его интерфейсе возвращают код ошибки VFW_E_NOT_CONNECTED. Множество свойств видеорендерера постоянно между моментами успешного соединения и отсоединения. Поскольку этот интерфейс совместим с автоматизацией, булевы значения могут быть OAFALSE(0)или OATRUE(-1).</P>
<P>Кроме методов, наследуемых от IDispatch, интерфейс IVideoWindow предоставляет методы, описанные в далееидущей табличке:</P>
<TABLE border="0" cellspacing="2" cellpadding="5"><TR>
<TH><STRONG>Метод</STRONG></TH>
<TH><STRONG>Описание</STRONG></TH>
</TR>
<TR>
<TD>get_AutoShow</TD>
<TD>Всегда ли видеорендерер автоматически показывает видеоокно, когда он получает видеоданные</TD>
</TR>
<TR>
<TD>get_BackgroundPalette</TD>
<TD>Всегда ли видеоокно освобождает свою палитру в бэкграунде</TD>
</TR>
<TR>
<TD>get_BorderColor</TD>
<TD>Возвращает цвет, который появляется около краев прямоугольника назначения</TD>
</TR>
<TR>
<TD>get_Caption</TD>
<TD>Возвращает надпись видеоокна</TD>
</TR>
<TR>
<TD>get_FullScreenMode</TD>
<TD>Всегда ли видеорендерер работает в полнооконном режиме</TD>
</TR>
<TR>
<TD>get_Height</TD>
<TD>Возвращает высоту видеоокна</TD>
</TR>
<TR>
<TD>get_Left</TD>
<TD>Возвращает x-коордианту окна</TD>
</TR>
<TR>
<TD>get_MessageDrain</TD>
<TD>Возвращает окно, которое получает сообщения от мышки и клавиатуры</TD>
</TR>
<TR>
<TD>get_Owner</TD>
<TD>Возвращает родительское окно видеоокна</TD>
</TR>
<TR>
<TD>get_Top</TD>
<TD>Возвращает y-координату окна</TD>
</TR>
<TR>
<TD>get_Visible</TD>
<TD>Видимо ли видеоокно</TD>
</TR>
<TR>
<TD>get_Width</TD>
<TD>Возвращает ширину видеоокна</TD>
</TR>
<TR>
<TD>get_WindowState</TD>
<TD>Запрашивает состояние видеоокна (видимое, скрытое, минимизированное, максимизированное)</TD>
</TR>
<TR>
<TD>get_WindowStyle</TD>
<TD>Возвращает стиль видеоокна</TD>
</TR>
<TR>
<TD>get_WindowStyleEx</TD>
<TD>Возвращает расширенный стиль видеоокна</TD>
</TR>
<TR>
<TD>GetMaxIdealImageSize</TD>
<TD>Возвращает максимальный идеальный размер изображения для видеоокна</TD>
</TR>
<TR>
<TD>GetMinIdealImageSize</TD>
<TD>Возвращает минимальный идеальный размер изображения для видеоокна</TD>
</TR>
<TR>
<TD>GetRestorePosition</TD>
<TD>Возвращает положение восстановленного видеоокна (есть смысл вызывать, если оно находится в минимизированном или максимизированном состоянии)</TD>
</TR>
<TR>
<TD>GetWindowPosition</TD>
<TD>Возвращает позицию видеоокна</TD>
</TR>
<TR>
<TD>HideCursor</TD>
<TD>Показывает или скрывает курсор, когда мышка находится над окном</TD>
</TR>
<TR>
<TD>IsCursorHidden</TD>
<TD>Скрыт ли курсор</TD>
</TR>
<TR>
<TD>NotifyOwnerMessage</TD>
<TD>Пересылает сообщения видеоокну. МГФ вызывает этот метод для пересылки различных сообщений рендереру </TD>
</TR>
<TR>
<TD>put_AutoShow</TD>
<TD>Устанавливает, должен ли видеорендерер автоматически показывать видеоокно при получении видеоданных (по умолчанию, при изменении графом фильтров состояния с приостановленного к запущенному, видеорендерер показывает видеоокно и устанавливает его на переднем плане; если пользователь зарывает окно, оно не будет автоматически открыто снова)</TD>
</TR>
<TR>
<TD>put_BackgroundPalette</TD>
<TD>Устанавливает, должно ли видеоокно освобождать свою палитру в бэкграунде. Если должно и видеоизображение требует палитру, видеорендерер должен освободить палитру в бэкграунде. Все цвета, используемые палитрой, должны быть заменены их близким соответствием  в палитре дисплея для рисования. Это гарантирует то, приложение не нарушит палитру. Но это скажется на быстродействии</TD>
</TR>
<TR>
<TD>put_BorderColor</TD>
<TD>Устанавливает цвет, который появляется около краев прямоугольника назначения (эта операция имеет смысл, если прямоугольник, в котором происходит отображение видео, меньше клиенского простанства видеоокна)</TD>
</TR>
<TR>
<TD>put_Caption</TD>
<TD>Устанавливает надпись видеоокна</TD>
</TR>
<TR>
<TD>put_FullScreenMode</TD>
<TD>Устанавливает или отменяет полноэкранный режим</TD>
</TR>
<TR>
<TD>put_Height</TD>
<TD>Устанавливает высоту видеоокна</TD>
</TR>
<TR>
<TD>put_Left</TD>
<TD>Устанавливает x-координату видеоокна</TD>
</TR>
<TR>
<TD>put_MessageDrain</TD>
<TD>Устанавливает окно, которое должно получать сообщения от клавиатуры и мыши от видеоокна</TD>
</TR>
<TR>
<TD>put_Owner</TD>
<TD>Устанавливает родительское окно для видеоокна</TD>
</TR>
<TR>
<TD>put_Top</TD>
<TD>Устанавливает y-координату видеоокна</TD>
</TR>
<TR>
<TD>put_Visible</TD>
<TD>Показывает или скрывает видеоокно</TD>
</TR>
<TR>
<TD>put_Width</TD>
<TD>Устанавливает ширину видеоокна</TD>
</TR>
<TR>
<TD>put_WindowState</TD>
<TD>Показывает, скрывает, минимизирует или максимизирует видеоокно</TD>
</TR>
<TR>
<TD>put_WindowStyle</TD>
<TD>Устанавливает оконный стиль для видеоокна</TD>
</TR>
<TR>
<TD>put_WindowStyleEx</TD>
<TD>Устанавливает расширенный оконный стиль для видеоокна</TD>
</TR>
<TR>
<TD>SetWindowForeground</TD>
<TD>Устанавливает положение видеоокна на самом верху Z-порядка</TD>
</TR>
<TR>
<TD>SetWindowPosition</TD>
<TD>Устанавливает положение видеоокна</TD>
</TR>
</TABLE>
<P>Как видим, интерфейс IVideoWindow имеет достаточно много методов (об их подробностях можно узнать из того же MSDN'а), большинство из которых имеет совершенно прозрачный смысл, и только для некоторых (как, например, put_FullScreenMode) характерны важные нюансы.</P>

<H4>VMR Windowless Mode</H4>
<P>Здесь - VMR Windowless Mode</P>

<H4>IVMR WindowlessControl9</H4>
<P>Теперь обратимся к интерфейсу IVMRWindowlessControl9. Я не хотел пока заострять на нем внимания,- нам вполне хватило бы и IVideoWindow, но упомянуть все же нужно. Этот интерфейс управляет отображением фильтра рендеринга VMR-9 (Video Mixing Renderer Filter 9; почему он так называется и что оно все такое - сейчас не важно) видеопотока без окна-контейнера. Перед использованием методов этого интерфейса приложения должны установить VMR-9 в безоконный (windowless) режим.</P>
<P>IVMRWindowlessControl9 кроме методов, наследуемых от IUnknown, предоставляет также и следующие:</P>
<TABLE border="0" cellspacing="2" cellpadding="5"><TR>
<TH><STRONG>Метод</STRONG></TH>
<TH><STRONG>Описание</STRONG></TH>
</TR>
<TR>
<TD>DisplayModeChange</TD>
<TD>Информирует VMR о том, что приложение получило сообщение WM_DISPLAYCHANGE.Приложение должно вызывать этот метод всегда, когда оно получает оконное сообщение WM_DISPLAYCHANGE, но только если VMR находится в безоконном (windowless) режиме</TD>
</TR>
<TR>
<TD>GetAspectRatioMode</TD>
<TD>Возвращает текущий aspect ratio режима отображения</TD>
</TR>
<TR>
<TD>GetBorderColor</TD>
<TD>Возвращает текущий цвет рамки, используемый VMR'ом</TD>
</TR>
<TR>
<TD>GetCurrentImage</TD>
<TD>Возвращает копию текущего изображения, показываемого VMR'ом. Изображение возвращается в формате пакованного Windows DIB. Этот метод может быть вызван в любое время, независимо от того, в каком состоянии находится фильтр. Вызывающий ответственен за освобождение возвращаемой памяти с помощью вызова coTaskMemFree. Использование этой функции замедляет воспроизведение</TD>
</TR>
<TR>
<TD>GetMaxIdealVideoSize</TD>
<TD>Возвращает максимальный размер видео, который может быть отображен VMR'ом без incurring significant performance или ухудшения качества изображения</TD>
</TR>
<TR>
<TD>GetMinIdealVideoSize</TD>
<TD>Возвращает минимальный размер видео, который может быть отображен VMR'ом без incurring significant performance или ухудшения качества изображения</TD>
</TR>
<TR>
<TD>GetNativeVideoSize</TD>
<TD>Возвращает un-stretched размер видео и aspect ratioвидео</TD>
</TR>
<TR>
<TD>GetVideoPosition</TD>
<TD>Возвращает текущие прямоугольники источника и назначения, используемые для отображения видео</TD>
</TR>
<TR>
<TD>RepaintVideo</TD>
<TD>Перерисовывает текущий видеокадр</TD>
</TR>
<TR>
<TD>SetAspectRatioMode</TD>
<TD>Устанавливает текущий aspect ratio режима отображения</TD>
</TR>
<TR>
<TD>SetBorderColor</TD>
<TD>Устанавливает цвет рамки для использования VMR'ом.Этот цвет используется для заливки любой площади прямоугольника назначения, не содержащего видео. Обычно используется в следующих двух случаях:Когда видео straddles два монитораWhen the VMR is trying to maintain the aspect ratio of the movies by letter-boxing the video to fit within the specified destination rectangle. See SetAspectRatioMode. </TD>
</TR>
<TR>
<TD>SetVideoClippingWindow</TD>
<TD>Указывает содержащему окну, что видео должно быть clipped to.</TD>
</TR>
<TR>
<TD>SetVideoPosition</TD>
<TD>Устанавливает для видео прямоугольники источника и назначения.</TD>
</TR>
</TABLE>
<P>Итак, класс TVideoWindow может пребывать в двух режимах - vmNormal и vmVMR, в зависимости от чего (в методе NotifyFilter) создает либо Video Renderer Filter, либо Video Mixing Renderer Filter 9 - фильтры для видеоотображения - и присваивает созданный фильтр рендеринга внутренней переменной FBaseFilter; имеет также внутреннюю переменную, представляющую менеджер графа фильтров. Естественно, что прочие поля и методы TVideoWindow предназначены для вызова методов интерфейсов IVideoWindow или IVMRWindowlessControl9 и фильтров VMR или VMR9. Поэтому сначала совсем коротко рассмотрим фильтры рендеринга, а затем - прочие свойства и методы TVideoWindow.</P>
<P>
</P>

<H4>Краткий экскурс в фильтры видеоотображения</H4>

<H4>Video Renderer Filter</H4>
<P>Этот фильтр - подходящий вариант для надежного видеовоспроизведения.</P>
<P>Нужно заметить, что в Windows XP фильтром видеовоспроизведения по умолчанию есть Video Mixing Renderer (VMR). И VMP, и Video Renderer имеют общее "дружественное имя" - "Video Renderer". На всех других платформах по умолчанию фильтром видеовоспроизведения есть Video Renderer, хотя приложения и могут использовать VMR-9 для использования дополнительных возможностей видеовоспроизведения.</P>
<P>Video Renderer использует DirectDraw и оверлейные поверхности, если их поддерживает видеокарта. Менеджер графа фильтров предоставляет интерфейс IVideoWindow, который позволяет приложению устанавливать и возвращать свойства Video Renderer'а. На новых видеокартах Video Renderer поддерживает полноэкранный режим отображения. В других случаях МГФ автоматически переключается на фильтр полноэкранного отображателя ( <U>Full Screen Renderer</U>  ) для полноэкранного режима. См. также <STRONG><A href="ivideowindowput_fullscreenmode.htm">IVideoWindow::put_FullScreenMode</A></STRONG>.</P>
<P>Нужно заметить, что обычно фильтры таких видеоокон обрабатывают сообщения на рабочем потоке, созданном МГФ. Однако, если приложение напрямую создает фильтр с использованием вызова <STRONG>CoCreateInstance</STRONG>, видеокно обрабатывает сообщение на потоке приложения. В этом случае поток приложения должен иметь цикл обработки для диспетчеризации сообщений, предназначенных видеоокну. Этот поток не должен прекращать выполнение до тех пор, пока Video Renderer не вызовет финальный Release, который происходит в том случае, когда прекращает работу МГФ. В противном случае приложение может получить взаимоблокировку.</P>
<P>В следующей таблице описываются свойства фильтра Video Renderer:</P>
<TABLE border="0" cellspacing="2" cellpadding="5"><TR>
<TH><STRONG>Свойство</STRONG></TH>
<TH><STRONG>Описание</STRONG></TH>
</TR>
<TR>
<TD>Интерфейсы фильтра</TD>
<TD><STRONG><A href="ibasefilterinterface.htm">IBaseFilter</A></STRONG>, <STRONG><A href="ibasicvideointerface.htm">IBasicVideo</A></STRONG>, <STRONG><A href="ibasicvideo2interface.htm">IBasicVideo2</A></STRONG>, <STRONG><A href="idirectdrawvideointerface.htm">IDirectDrawVideo</A></STRONG>, <STRONG><A href="ikspropertysetinterface.htm">IKsPropertySet</A></STRONG>, <STRONG><A href="imediapositioninterface.htm">IMediaPosition</A></STRONG>, <STRONG><A href="imediaseekinginterface.htm">IMediaSeeking</A></STRONG>, <STRONG><A href="iqualitycontrolinterface.htm">IQualityControl</A></STRONG>, <STRONG><A href="iqualpropinterface.htm">IQualProp</A></STRONG>, <STRONG><A href="ivideowindowinterface.htm">IVideoWindow</A></STRONG> </TD>
</TR>
<TR>
<TD>Медиатип входящего контакта</TD>
<TD>MEDIATYPE_Video</TD>
</TR>
<TR>
<TD>Интерфейсы входящего контакта</TD>
<TD><STRONG><A href="imeminputpininterface.htm">IMemInputPin</A></STRONG>, <STRONG><A href="ioverlayinterface.htm">IOverlay</A></STRONG>, <STRONG><A href="ipininterface.htm">IPin</A></STRONG>, <STRONG><A href="ipinconnectioninterface.htm">IPinConnection</A></STRONG>, <STRONG><A href="iqualitycontrolinterface.htm">IQualityControl</A></STRONG> </TD>
</TR>
<TR>
<TD>Медиатипы исходящего контакта</TD>
<TD>-</TD>
</TR>
<TR>
<TD>Интерфейсы исходящего контакта</TD>
<TD>-</TD>
</TR>
<TR>
<TD>CLSID фильтра</TD>
<TD>CLSID_VideoRenderer</TD>
</TR>
<TR>
<TD>CLSID страницы свойств</TD>
<TD>-</TD>
</TR>
<TR>
<TD>Исполнимый файл</TD>
<TD>quartz.dll</TD>
</TR>
<TR>
<TD>Merit</TD>
<TD>Windows 98, Me, NT, 2000: MERIT_PREFERRED Windows XP: MERIT_UNLIKELY</TD>
</TR>
<TR>
<TD>Категория фильтров</TD>
<TD>CLSID_LegacyAmFilterCategory</TD>
</TR>
</TABLE>
<P>Другие подробности, связанные с особенностями функционирования фильтра и поддержки отладки приложений quartz.dll, следует смотреть в MSDN.</P>

<H4>Video Mixing Renderer Filter 9</H4>
<P>Этот фильтр  расширяет возможности воспроизведения видео для всех платформ, поддерживающих DirectX. Он полностью интегрирован с 3D свойствами DirectX9. Например, можно легко добавлять видео к играм и другим 3D оболочкам или преобразовывать видеоизображения с использованием теневых пикселей Direct3D (3D pixel shaders) и других эффектов.</P>
<P>Этот фильтр не поддерживает видеопорты ( о видеопортах нужно что-нибудь сказать ).</P>
<P>Для обеспечения обратной совместимости VMR-9 не является фильтром отображения по умолчанию ни на какой системе. Для использования этого фильтра нужно добавить его к графу фильтров явно и отконфигурировать его перед соединением с любыми из его входящих контактов. VMR-9 использует собственный набор интерфейсов, структур, перечислителей, которые не всегда идентичны соответствующим типам данных, используемых VMR-7. Более подробно вопрос освещен в соответствующих разделах MSDN - <A href="usingthevideomixingrenderer.htm">Using the Video Mixing Renderer</A>. </P>

<H4>Video Mixing Renderer Filter 7</H4>


<H3>Свойства, методы и интерфейсы для TVideoWindow<A name="IDA4UBKE"></A></H3>
<P>Теперь мы можем перейти к рассмотрению класса TVideoWindow. Он предназначен для отображения видео и объявлен в файле DSPack.pas путем</P>
<DIV id="IDADVBKE">
<TABLE class="code" width="98%"><TR><TD>
<PRE>
TVideoWindow = <SPAN class="KEYWORD">class</SPAN>(TCustomControl, IFilter, IEvent)
</PRE>
</TD></TR></TABLE>
</DIV>
<P>Класс TCustomContol есть наследником TWinControl, поэтому понятно, что TVideoWindow дает возможность, среди прочего, работать с ним как с окном. Будем считать, что с этим предком все ясно, и сосредоточимся на интерфейсах IFilter и IEvent. Они объявлены как</P>
<DIV id="IDAJVBKE">
<TABLE class="code" width="98%"><TR><TD>
<PRE>
IFilter = <SPAN class="KEYWORD">interface</SPAN> [<SPAN class="STRING">'{887F94DA-29E9-44C6-B48E-1FBF0FB59878}'</SPAN>] 
<SPAN class="COMMENT">{ Return the IBaseFilter Interface (All DirectShow filters expose this interface). }</SPAN> 
<SPAN class="KEYWORD">function</SPAN> GetFilter: IBaseFilter; 
<SPAN class="COMMENT">{ Return the filter name (generally the component name). }</SPAN> 
<SPAN class="KEYWORD">function</SPAN> GetName: <SPAN class="KEYWORD">string</SPAN>; 
<SPAN class="COMMENT">{ Called by the @link(TFilterGraph) component, this method receive notifications 
on what the TFilterGraph is doing. if Operation = foGraphEvent then Param is the 
event code received by the FilterGraph.}</SPAN> 
<SPAN class="KEYWORD">procedure</SPAN> NotifyFilter(operation: TFilterOperation; Param: integer = 0); 
<SPAN class="KEYWORD">end</SPAN>; 
</PRE>
</TD></TR></TABLE>
</DIV>
<P>( НУЖНО УКАЗАТЬ, В КАКОМ ЗАГОЛОВОЧНОМ ФАЙЛЕ ЭТО ЗАДАНО )</P>
<P>и</P>
<DIV id="IDADWBKE">
<TABLE class="code" width="98%"><TR><TD>
<PRE>
IEvent = <SPAN class="KEYWORD">interface</SPAN> [<SPAN class="STRING">'{6C0DCD7B-1A98-44EF-A6D5-E23CBC24E620}'</SPAN>] 
<SPAN class="COMMENT">{ FilterGraph events. }</SPAN> 
<SPAN class="KEYWORD">procedure</SPAN> GraphEvent(Event, Param1, Param2: integer); 
<SPAN class="COMMENT">{ Control Events. }</SPAN> 
<SPAN class="KEYWORD">procedure</SPAN> ControlEvent(Event: TControlEvent; Param: integer = 0); 
<SPAN class="KEYWORD">end</SPAN>; 
</PRE>
</TD></TR></TABLE>
</DIV>
<P>Эти функции должны быть реализованы классом TVideoWindow. Кроме них, наиболее интересными есть функции SetFullScreen, VMRGetBitmap. Кроме этого, обратим внимание на для два private - члена - FAllocatorClass типа TAbstractAllocatorClass и FCurrentAllocator типа TAbstractAllocator. Их объявления:</P>
<DIV id="IDAVWBKE">
<TABLE class="code" width="98%"><TR><TD>
<PRE>
TAbstractAllocator = <SPAN class="KEYWORD">class</SPAN>(TInterfacedObject) 
<SPAN class="KEYWORD">constructor</SPAN> Create(<SPAN class="KEYWORD">out</SPAN> hr: HResult; wnd: THandle; d3d: IDirect3D9 = <SPAN class="KEYWORD">nil</SPAN>; 
d3dd: IDirect3DDevice9 = <SPAN class="KEYWORD">nil</SPAN>); virtual; abstract; 
<SPAN class="KEYWORD">end</SPAN>; 
TAbstractAllocatorClass = <SPAN class="KEYWORD">class</SPAN> <SPAN class="KEYWORD">of</SPAN> TAbstractAllocator; 
</PRE>
</TD></TR></TABLE>
</DIV>
<P>( ПУТЕМ ТРАССИРОВАНИЯ ВЫЯСНИТЬ, ЧТО ЭТО ЗА CREATE )</P>
<P>Рассмотрим также некоторые дополнительные интерфейсы, важные для понимания процесса отображения. Среди них - IVMRSurfaceAllocator, IVMRSurfaceAllocatorNotify,  IVMRImagePresenter.</P>
<H4>IVMRSurfaceAllocator</H4>
<P>Интерфейс IVMRSurfaceAllocator реализуется аллокатором-презентером (allocator-presenter), заданным по умолчанию для фильтра VMR-7. Он должен реализовываться любым plug-in allocator-presenter, который приложение предоставляет фильтру VMR-7. VMR-7 использует методы на этом интерфейсе для выделения, подготовку и освобождение поверхностей DirectDraw. Приложения не используют этот интерфейс. Для VMR-9 используется IVMRSurfaceAllocator9. Вдобавок к методам IUnknown, интерфейс IVMRSurfaceAllocator предоставляет такие методы:</P>
<TABLE border="0" cellspacing="2" cellpadding="5"><TR>
<TH><STRONG>Метод</STRONG></TH>
<TH><STRONG>Описание</STRONG></TH>
</TR>
<TR>
<TD>AdviseNotify</TD>
<TD>Вызывается VMR'ом для предоставления распределителя-презентера с указателем интерфейса для колбэк-уведомлений</TD>
</TR>
<TR>
<TD>AllocateSurface</TD>
<TD>Выделяется поверхность DirectDraw</TD>
</TR>
<TR>
<TD>FreeSurface</TD>
<TD>Освобождается поверхность DirectDraw</TD>
</TR>
<TR>
<TD>PrepareSurface</TD>
<TD>Подготавливается поверхность DirectDraw для декодирования в нее следующего видеофрейма</TD>
</TR>
</TABLE>
<P>А интерфейс IVMRSurfaceAllocator9 такие:</P>
<TABLE border="0" cellspacing="2" cellpadding="5"><TR>
<TH><STRONG>Метод</STRONG></TH>
<TH><STRONG>Описание</STRONG></TH>
</TR>
<TR>
<TD>AdviseNotify</TD>
<TD>Вызывается VMR'ом для предоставления распределителя-презентера с указателем интерфейса для колбэк-уведомлений</TD>
</TR>
<TR>
<TD>GetSurface</TD>
<TD>Возвращает DirectDraw-поверхность</TD>
</TR>
<TR>
<TD>InitializeDevice</TD>
<TD>Инициализируется устройство Direct3D</TD>
</TR>
<TR>
<TD>TerminateDevice</TD>
<TD>Освобождается устройство Direct3D</TD>
</TR>
</TABLE>

<H4>IVMRImagePresenter</H4>
<P>Интерфейс IVMRImagePresenter реализован задаваемым по умолчанию аллокатором-презентером для VMR-7. Он должен также быть реализован любым плагином аллокатора-презентера, предоставляемым приложением для VMR-7. VMR-7 использует методы на этом интерфейсе для информирования аллокатора-презентера, что будет представлен видеофрейм, содержащий поддерживаемую поверхность DirectDraw. Соответствующим фильтром для VMR-9 есть интерфейс <STRONG>IVMRImagePresenter9</STRONG>.</P>
<P>Вдобавок к методам, наследуемым от <STRONG>IUnknown</STRONG>, интерфейс IVMRImagePresenter предоставляет следующие методы:</P>
<TABLE border="0" cellspacing="2" cellpadding="5"><TR>
<TH><STRONG>Метод</STRONG></TH>
<TH><STRONG>Описание</STRONG></TH>
</TR>
<TR>
<TD>PresentImage</TD>
<TD>Вызывается в точно тот момент, когда будет видеокадр будет представлен.</TD>
</TR>
<TR>
<TD>StartPresenting</TD>
<TD>Вызывается только перед началом видеотображения</TD>
</TR>
<TR>
<TD>StopPresenting</TD>
<TD>Вызывается только после окончания видеопроигрывания</TD>
</TR>
</TABLE>

<H4>IVMRSurfaceAllocatorNotify</H4>
<P>Интерфейс <STRONG>IVMRSurfaceAllocatorNotify</STRONG> реализован фильтром VMR-7. Приложения используют этот интерфейс для установки собственного аллокатора-презентера и аллокатор-презентер использует этот интерфейс для информирования VMR-7 об изменениях системного окружения, влияющего на поверхности DirectDraw.</P>
<P>Для того, чтобы приложение получило этот интерфейс, VMR должен быть запущен в renderless режиме.</P>
<P>Соответствующим интерфейсом для VMR-9 есть интерфейс <STRONG>IVMRSurfaceAllocatorNotify9</STRONG>.</P>
<P>Вдобавок к интерфейсам, наследуемым от IUnknown, этот интефейс предоставляет следующие методы:</P>
<TABLE border="0" cellspacing="2" cellpadding="5"><TR>
<TH><STRONG>Метод</STRONG></TH>
<TH><STRONG>Описание</STRONG></TH>
</TR>
<TR>
<TD>AdviseSurfaceAllocator</TD>
<TD>Вызывается приложением для информирования VMR об использовании пользовательского аллокатора-презентера</TD>
</TR>
<TR>
<TD>ChangeDDrawDevice</TD>
<TD>Уведомляет VMR, что проигрывающее устройство DirectDraw было изменено</TD>
</TR>
<TR>
<TD>NotifyEvent</TD>
<TD>Вызывается аллокатором-презентером для информирования VMR'а о любых значимых событиях DirectShow на всем протяжении процесса выделения или представления</TD>
</TR>
<TR>
<TD>RestoreDDrawSurface</TD>
<TD>Уведомляет VMR о том, что была обнаружена потеря устройства DirectDraw</TD>
</TR>
<TR>
<TD>SetBorderColor</TD>
<TD>Указывается для VMR'а, какой цвет используется в области экранного прямоугольника, который не будет использован для видео, например, когда видео выводится как "letterbox"</TD>
</TR>
<TR>
<TD>SetDDrawDevice</TD>
<TD>Устанавливает начальное устройство и монитор DirectDraw для использования для видеопроигрывания.</TD>
</TR>
</TABLE>

<H4>SetAllocator</H4>
<P>Этот метод имеет очень простую реализацию:</P>
<DIV id="IDA11BKE">
<TABLE class="code" width="98%"><TR><TD>
<PRE>
<SPAN class="KEYWORD">procedure</SPAN> TVideoWindow.SetAllocator(Allocator: TAbstractAllocatorClass; UserID: Cardinal); 
<SPAN class="KEYWORD">begin</SPAN> 
  FAllocatorClass := Allocator; 
  FRenderLessUserID := UserID; 
<SPAN class="KEYWORD">end</SPAN>; 
</PRE>
</TD></TR></TABLE>
</DIV>
<P>Этот метод используется, в частности, для установки класса аллокатора в методах класса TBCTransInPlaceFilter, TBCTransInPlaceOutputPin.</P>
<P>О нем (этом методе) нужно бы еще что-нибудь, хотя бы вскользь, сказать.</P>

<H4>NotifyFilter</H4>
<P>Объявление этого метода -</P>
<DIV id="IDAN2BKE">
<TABLE class="code" width="98%"><TR><TD>
<PRE>
<SPAN class="KEYWORD">procedure</SPAN> TVideoWindow.NotifyFilter(operation: TFilterOperation; Param: integer);
</PRE>
</TD></TR></TABLE>
</DIV>
<P>Передаваемый параметр operation имеет перечислимый тип:</P>
<DIV id="IDAT2BKE">
<TABLE class="code" width="98%"><TR><TD>
<PRE>
TFilterOperation = ( 
  foAdding, <SPAN class="COMMENT">// Перед добавлением фильтра в граф </SPAN>
  foAdded, <SPAN class="COMMENT">// После добавления фильтра в граф</SPAN>
  foRemoving, <SPAN class="COMMENT">// Перед удалением фильтра из графа</SPAN>
  foRemoved, <SPAN class="COMMENT">// После удаления фильтра из графа</SPAN>
  foRefresh <SPAN class="COMMENT">// Уведомления дизайнера для обновления фильтра</SPAN>
); 
</PRE>
</TD></TR></TABLE>
</DIV>
<P>И метод выполняет разнообразные вспомагательные операции при уведомлениях с различным значением операции и в зависимости от разных текущих режимов - установка режима отображения, информирование VMR'а об использовании пользовательского аллокатора-презентера, установки пропорций и т.п.</P>

<H4>SetFullScreen</H4>
<P>Устанавливает полноэкранный режим (путем простой установки размеров окна вывода в полный экран) или отказывается от использования полноэкранного режима.</P>

<H4>GraphEvent</H4>
<P>Используется для обработки двух типов событий - связанных с изменением палитры (EC_PALETTE_CHANGED) и установкой типа механизма рендеринга (EC_VMR_RENDERDEVICE_SET). В обоих случаях суть сводится к вызову методов интерфейса IVideoWindow - put_Caption (для установки заголовка видеоокна) и put_MessageDrain (для указания окна для пересылки сообщений от мышки и клавиатуры от видеоокна).</P>

<H4>ControlEvent</H4>
<P>Используется для обработки управляющих событий ceDVDRendered (фильтр был удален) и cePlay (было начато проигрывание).</P>

<H4>VMRGetBitmap</H4>
<P>Используется для записи в поток текущего изображения.</P>


<H3>Класс TDSVideoWindowEx2<A name="IDA13BKE"></A></H3>
<P>Есть альтернативой для обычного способа отображения видео (с помощью TVideoWindow), который дает простой способ для использования оверлейной графики в приложениях.</P>
<P>Наиболее важными private-членами этого класса, необходимыми для достижения декларируемых целей есть:</P>
<DIV id="IDAC4BKE">
<TABLE class="code" width="98%"><TR><TD>
<PRE>
FVideoWindow - представляющий интерфейс IVideoWindow;
FFilterGraph - типа TFilterGraph; 
FBaseFilter - интерфейс IBaseFilter; 
FOverlayMixer - интерефйс IBaseFilter; 
FVideoRenderer - интерфейс IBaseFilter; 
FDDXM - интерфейс IDDrawExclModeVideo
</PRE>
</TD></TR></TABLE>
</DIV>
<P>И методы, наиболее важные из которых мы сейчас и рассмотрим.</P>
<P>Метод </P>
<DIV id="IDAI4BKE">
<TABLE class="code" width="98%"><TR><TD>
<PRE>
<SPAN class="KEYWORD">procedure</SPAN> NotifyFilter(operation: TFilterOperation; Param: integer = 0) 
</PRE>
</TD></TR></TABLE>
</DIV>
<P>выполняет задачи, сходные с задачами одноименного метода класса TVideoWindow но с, естественно, совершенно другой реализацией.</P>
<P>То же самое относится и к следующейму методу –</P>
<DIV id="IDAQ4BKE">
<TABLE class="code" width="98%"><TR><TD>
<PRE>
<SPAN class="KEYWORD">procedure</SPAN> GraphEvent(Event, Param1, Param2: integer),
</PRE>
</TD></TR></TABLE>
</DIV>
<P>но обрабатывается также событие изменения часов синхронизации.</P>
<P>Метод </P>
<DIV id="IDAY4BKE">
<TABLE class="code" width="98%"><TR><TD>
<PRE>
<SPAN class="KEYWORD">procedure</SPAN> ControlEvent(Event: TControlEvent; Param: integer = 0),
</PRE>
</TD></TR></TABLE>
</DIV>
<P>как и прежде, обрабатывает события ceDVDRendered, cePlay, но вдобавок к ним еще и cePause, ceStop,ceFileRendered. И обработка становится более слоджной, поскольку в данном случае мі имеем бОльшее количество взаимодействующих компонент. </P>
<P>В методе </P>
<DIV id="IDAA5BKE">
<TABLE class="code" width="98%"><TR><TD>
<PRE>
<SPAN class="KEYWORD">procedure</SPAN> SetFilterGraph(AFilterGraph: TFilterGraph) 
</PRE>
</TD></TR></TABLE>
</DIV>
<P>производится установка графа фильтров.</P>
<P>Очень важным методом есть </P>
<DIV id="IDAI5BKE">
<TABLE class="code" width="98%"><TR><TD>
<PRE>
<SPAN class="KEYWORD">function</SPAN> UpdateGraph : HResult; 
</PRE>
</TD></TR></TABLE>
</DIV>
<P>который служит для обновления графа фильтров и вызывается при различных изменениях состояний класса. Он строит ту часть графа фильтров, которая ответственна за видеотображение. Если используется OverlayMixer, то устанавливается эксклюзивный полноэкранный режим с помощью интерфейса <STRONG>IDDrawExclModeVideo</STRONG>. В случе же, когда используется фильтр VMR, производится попытка его вместо OverlayMixer'а. В процессе этого соединения производится проверка, не используется ли фильтр декодера Line21, поскольку Overlay Mixer не может быть соединен с Line21 Decoder2. А затем производится соединения VMR'а c Overlay Mixer'ом (вновь созданным, в случае необходимости).</P>

<H2>Захват без отображения<A name="IDAS5BKE"></A></H2>
<H2>Литература и ссылки<A name="IDAW5BKE"></A></H2>
<OL>
<LI>Самый главный ресурс - MSDN. Онлайн: <A href="http://msdn.microsoft.com/archive/default.asp?url=/archive/en-us/directx9_c/directx/htm/introductiontodirectshow.asp">http://msdn.microsoft.com/archive/default.asp?url=/archive/en-us/directx9_c/directx/htm/introductiontodirectshow.asp</A> </LI>
<LI>DirectShow - форум: <A href="http://groups-beta.google.com/group/microsoft.public.win32.programmer.directx.video?gvc=2">http://groups-beta.google.com/group/microsoft.public.win32.programmer.directx.video?gvc=2</A> </LI>
<LI><A href="http://sourceforge.net/projects/guliverkli/">http://sourceforge.net/projects/guliverkli/</A> </LI>
<LI>Полезно также почитать: <A href="http://german.doom9.org/index.html?/graphedit_mp3-ger.htm">http://german.doom9.org/index.html?/graphedit_mp3-ger.htm</A> </LI>
<LI><A href="http://www.ixbt.com/divideo/videoonpc-p3.shtml">http://www.ixbt.com/divideo/videoonpc-p3.shtml</A> </LI>
<LI><A href="http://divxhome.bmtelecom.ru/sub.html">http://divxhome.bmtelecom.ru/sub.html</A> </LI>
<LI><A href="http://www.ruvideo.com/body.php?n=edit&amp;id=00000008">http://www.ruvideo.com/body.php?n=edit&amp;id=00000008</A> </LI>
<LI><A href="http://www.delphikingdom.com/asp/viewitem.asp?catalogid=270">http://www.delphikingdom.com/asp/viewitem.asp?catalogid=270</A> </LI>
<LI>DSPack: <A href="http://www.progdigy.com/">http://www.progdigy.com/</A> </LI>
<LI><A href="http://www.delphikingdom.com/asp/viewitem.asp?catalogid=270">http://www.delphikingdom.com/asp/viewitem.asp?catalogid=270</A> - маленькое введение в DirectShow </LI>
<LI>Документация по BT-8xx </LI>
<LI><A href="http://codecs.org.ua/">http://codecs.org.ua/</A> </LI>
<LI><A href="http://www.virtualdub.org/">http://www.virtualdub.org/</A> - изучайте исходники </LI>
<LI><A href="http://www.itc.ua/print.phtml?ID=14525">http://www.itc.ua/print.phtml?ID=14525</A> - RTSP </LI>
<LI>- RFC RTSP </LI>
<LI>
</LI>
<LI><A href="http://www.3ivx.com/technology/filters/">http://www.3ivx.com/technology/filters/</A> - фильтры 3ivx для MP4 </LI>
<LI>Короче говоря, ищите сами, выше приведено предостаточно информации </LI>
<LI><A href="http://www.alparysoft.ru/">http://www.alparysoft.ru/</A> - сайт одной из компаний, занимающейся мультимедийными технологиями, полезно также посмотреть на форумы <A href="http://www.alparysoft.ru/forum/viewforum.php?f=10">http://www.alparysoft.ru/forum/viewforum.php?f=10</A> и <A href="http://www.alparysoft.ru/forum/viewforum.php?f=10">http://www.alparysoft.ru/forum/viewforum.php?f=10</A>, и <A href="http://www.alparysoft.ru/forum/viewforum.php?f=8">http://www.alparysoft.ru/forum/viewforum.php?f=8</A>, и <A href="http://www.alparysoft.ru/products.php?item=12">http://www.alparysoft.ru/products.php?item=12</A> (трансформационные фильтры - простые и не самые простые эффекты для изображений).</LI>
<LI><A href="http://www.elecard.ru/forum/">http://www.elecard.ru/forum/</A> - здесь форумы фирмы Elecard - разработчика фильтров Moonlight.</LI>
<LI><A href="http://vcdrookie.com/rus/HomePage">http://vcdrookie.com/rus/HomePage</A> - руководства по DVD, VCD, MPEG, AVI.</LI>
<LI><A href="http://www.a2ii.com/tech/directx/">http://www.a2ii.com/tech/directx/</A> - использование DirectShow в C#</LI>
</OL>
<DIV align="right">
<FONT style="font-family:arial;font-size:9pt;color:#8088a0"><I><HR color="#8088a0" width="100%" size="1">
                Любой из материалов, опубликованных на этом сервере, не может быть воспроизведен в какой бы
                то ни было форме и какими бы то ни было средствами без письменного разрешения владельцев авторских
                прав. 
             </I></FONT>
</DIV>
<a href="http://directshow.wonderu.com/">> к содержанию</a>
<br><br>
<!--Rating@Mail.ru LOGO--><a target=_top
href="http://top.mail.ru/jump?from=1156223"><img
SRC="http://d4.ca.b1.a1.top.list.ru/counter?id=1156223;t=133;l=1"
border=0 height=40 width=88
alt="Рейтинг@Mail.ru"/></a><!--/LOGO-->
</BODY>
</HTML>